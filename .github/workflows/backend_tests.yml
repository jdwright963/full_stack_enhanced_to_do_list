# This YAML file defines a GitHub Actions "workflow". A workflow is an automated process that
# runs one or more "jobs" whenever a specified event occurs in the repository.
# This specific workflow is designed to automatically run the backend tests.

# The 'name' key sets the display name for this entire workflow.
# This is the name you will see in the "Actions" tab of the GitHub repository,
# making it easy to identify among other potential workflows (e.g., "Deploy to Production").
name: Backend Tests

# The 'on' key specifies the events that will trigger this workflow to run.
# `[push, pull_request]` means this workflow will automatically execute whenever:
#  1. Code is pushed to any branch in the repository.
#  2. A pull request is created or updated....
# This is a standard CI practice to ensure code quality is checked on every change.
on: [push, pull_request]

# The 'jobs' key defines one or more jobs that the workflow will execute.
# Jobs can run in parallel by default or be configured to run sequentially.
jobs:

  # This line defines a single job with the unique ID 'test'.
  # It's the main container for the steps that will run our backend tests.
  test:

    # The 'runs-on' key specifies the type of virtual machine, or "runner", this job will run on.
    # `ubuntu-latest` tells GitHub to provide a fresh virtual environment running the latest
    # stable version of Ubuntu Linux for this job.
    runs-on: ubuntu-latest

    # The 'steps' key defines a sequence of tasks that will be executed in order within the 'test' job.
    # If any step fails, the job will stop by default.
    steps:

      # The hyphen `-` indicates a list item, making this the first step.
      # The `uses` keyword tells this step to run a pre-built, reusable community action.
      # `actions/checkout@v3` is a critical official action that checks out the repository's code
      # and downloads it onto the runner, so the workflow can access the files (like test scripts).
      # The `@v3` pins it to a specific major version for stability and security.
      - uses: actions/checkout@v3

      # This is the second step in the job, clearly labeled 'Set up Python'.
      - name: Set up Python

        # It uses the official `setup-python` action to install Python onto the runner.
        uses: actions/setup-python@v4

        # The 'with' block provides input parameters to the action being used.
        with:

          # This input tells the action to install and make Python version 3.11 available in the environment.
          # This ensures that the tests always run against the same version of Python for consistency.
          python-version: 3.11

      # This is the third step, responsible for installing the necessary Python packages.
      - name: Install dependencies

        # The 'run' keyword executes shell commands directly on the runner.
        # The '|' signifies a multi-line script, where each line is a separate command.
        # The first command creates a Python virtual environment named 'venv'.
        # It's a best practice to isolate project dependencies from the system's global packages.
        # The second command activates the virtual environment we just created.
        # Any subsequent `pip` or `python` commands will now use the environment inside the 'venv' folder.
        # The third command uses pip (Python's package installer) to install all libraries listed in the `requirements.txt` file.
        # This file should contain `pytest` and `requests` for the tests to work.
        run: |
          python -m venv venv
          source venv/bin/activate
          pip install -r requirements.txt
         
      #  The purpose of this `env` block is to securely provide all the necessary secret environment
      # variables to the commands that will be executed in the `run` step below.
      #
      # Without this, the application would fail to start because it wouldn't be able to connect
      # to the database or initialize the authentication system.
      #
      # SYNTAX BREAKDOWN: KEY: $`{{ secrets.VALUE }}`
      #
      # - `KEY:` (e.g., `CI_DATABASE_URL:`): This is the name of the environment variable as the
      #   application expects to find it (e.g., via `process.env.CI_DATABASE_URL`).
      #
      # - $`{{ ... }}`: This is the special syntax used in GitHub Actions to access context
      #   and expression information.
      #
      # - `secrets.VALUE`: This is how we access the encrypted secrets that are stored in the
      #   repository's settings. The `VALUE` part must exactly match the name we gave the
      #   secret in the GitHub UI.
      #
      # This entire block securely injects the values from the GitHub Secrets into the
      # virtual machine's environment just before the `run` commands are executed
      - name: Start Next.js server
        env:
          CI_DATABASE_URL: ${{ secrets.DATABASE_URL }}
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          AUTH_DISCORD_ID: ${{ secrets.AUTH_DISCORD_ID }}
          AUTH_DISCORD_SECRET: ${{ secrets.AUTH_DISCORD_SECRET }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}

        # This multi-line script prepares the full testing environment and starts the application server.
        # It executes the following commands in sequence:
        # 1. `export DATABASE_URL...`: This is a critical step for preventing CI race conditions. It constructs
        #    the final database connection string by taking the base URL directly from the GitHub secret
        #    and appending a unique schema name (`?schema=backend_tests`). This ensures that this job's database
        #    is completely isolated from other parallel jobs, like the Playwright E2E tests.
        # 2. `npm ci`: ("Clean Install") This command installs the exact Node.js dependencies specified in the
        #    `package-lock.json` file, ensuring a reproducible environment for every workflow run.
        # 3. `npx prisma migrate reset --force`: This command completely wipes the isolated database schema
        #    and applies all migrations from scratch. This guarantees that the tests always run against a
        #    clean, predictable, and up-to-date database schema.
        # 4. `npm run dev > next_server.log 2>&1 &`: This command starts the Next.js development server.
        #    The `>` redirects all standard output and `2>&1` redirects all error output to the `next_server.log`
        #    file for later debugging. The `&` at the end runs the server as a background process, allowing
        #    the workflow to proceed to the next steps while the server is running.
        run: |
          export DATABASE_URL="${{ secrets.DATABASE_URL }}?schema=backend_tests"
          npm ci
          npx prisma migrate reset --force
          npm run dev > next_server.log 2>&1 &

      # This step acts as an "intelligent wait", ensuring the tests do not start until the server is fully running.
      - name: Health check Next.js server
        
        # This runs a multi line shell script that is a robust polling mechanism that tries to connect to the server in a loop.
        # It is designed to be the intelligent wait mechanism that ensures the server is fully ready before tests begin.
        #
        # `for i in {1..10}; do ... done`
        # This is a standard shell loop that will execute the code between `do` and `done` a maximum of 10 times.
        # It acts as a timeout mechanism, giving the server a total of 20 seconds (10 attempts * 2 seconds) to start.
        #
        # `if curl ...; then ... fi`
        # This is a conditional statement. It executes the `curl` command and checks its exit code. If the exit
        # code is 0 (success), it runs the code inside the `then` block. Otherwise, it continues the loop.
        #
        # `curl -sSf http://localhost:3000 > /dev/null`
        # This is the core of the health check.
        #   - `curl`: A command-line tool to make web requests. Here, it makes a GET request.
        #   - `-s`: The "silent" flag. It prevents curl from showing a progress meter or other informational
        #     output. We only care about the result, not the process.
        #   - `-S`: The "show error" flag. It is paired with `-s`. It tells curl that if a system-level
        #     error occurs (e.g., "cannot resolve host"), it should still print that error to the console.
        #   - `-f`: The "fail fast" or "fail on server error" flag. This is the MOST CRITICAL flag.
        #     Normally, if a server responds with an error like 404 (Not Found) or 500 (Internal Server Error),
        #     `curl` would still exit with a success code `0`. The `-f` flag changes this behavior: if the server
        #     responds with an HTTP error code, `curl` will immediately exit with a failure code `22`.
        #     This is what makes the `if` statement work correctly.
        #   - `http://localhost:3000`: The URL being checked. This is the default address for the Next.js dev server.
        #   - `> /dev/null`: This redirects the standard output (the actual HTML of the page) to `/dev/null`,
        #     a special file that discards whatever is sent to it. We don't need to see the page content,
        #     we only care that the request was successful.
        #
        # `echo "Next.js server is up!"` and `exit 0`
        # If the `curl` command succeeds, this code runs. It prints a success message to the log and then
        # immediately terminates the entire step with an exit code of `0`, which signifies success.
        #
        # `sleep 2`
        # If the `curl` command fails, the script waits for 2 seconds before starting the next iteration of the loop.
        # This prevents it from spamming the server with requests and gives the server more time to start.
        #
        # The code block after `done`
        # This code only runs if the `for` loop completes all 10 attempts without a single successful `curl` command.
        #   - `echo "Next.js server failed to start."`: Prints a clear error message.
        #   - `cat next_server.log`: Displays the entire log file from the server, which is essential for
        #     debugging why it failed to start.
        #   - `exit 1`: Terminates the entire step with an exit code of `1`, which signifies failure and will
        #     cause the entire GitHub Actions job to fail.
        run: |
          for i in {1..10}; do
            if curl -sSf http://localhost:3000 > /dev/null; then
              echo "Next.js server is up!"
              exit 0
            fi
            echo "Waiting for Next.js server..."
            sleep 2
          done
          echo "Next.js server failed to start."
          cat next_server.log
          exit 1


      # This step executes the backend API tests using the Pytest framework.
      - name: Run backend tests

        # This `run` block executes two commands in a new shell session:
        # 1. `source venv/bin/activate`: This command re-activates the Python virtual environment.
        #    It's necessary to run this again because each `run` step in a GitHub Actions workflow
        #    is a completely separate and isolated shell session. The activation from the
        #    "Install dependencies" step does not persist to this one. Re-activating ensures that
        #    the `pytest` command uses the correct dependencies that were installed inside `venv`.
        #
        # 2. `pytest tests_api/`: This command runs the Pytest test runner. It looks for all test
        #    files in the `tests_api/` directory and executes them. If any test assertion fails,
        #    Pytest will exit with an error code, which automatically fails this step and the entire
        #    workflow job.
        run: |
          source venv/bin/activate
          pytest tests_api/

      # This step is a crucial debugging tool that runs unconditionally at the end of the job.
      # This allows us to see the server's logs to diagnose the cause of any potential 
      # failures, or to review the server's state on a successful run.
      - name: Display server logs on failure

        # This condition ensures this step will execute regardless of whether the
        # previous steps succeeded or failed.
        if: always()

        # This script prints the full server logs to the workflow output for debugging purposes.
        # The `echo` command adds a clear, human-readable header to the GitHub Actions log,
        # making this specific section easy to find. The `cat next_server.log` command then
        # reads the entire contents of the log file (which captured all output from the
        # `npm run dev` process) and displays it directly in the workflow's output.
        run: |
          echo "--- Displaying Next.js server logs after test execution ---"
          cat next_server.log
