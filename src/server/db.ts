// This file, `src/server/db.ts`, is automatically generated by `create-t3-app`.
// Its primary and crucial purpose is to initialize and export a single, globally available
// instance of the Prisma Client. Prisma Client is the tool used to communicate with the database.
//
// - In a development environment, when you save a file, Next.js
//   doesn't restart the whole server. Instead, it cleverly "reloads" only the code that
//   has changed. This is called "hot reloading," and it makes development much faster.
//
// - A side effect of this is that the code in this `db.ts` file might be
//   re-run on every save. If we weren't careful, we would create a new Prisma Client
//   (and a new database connection) every single time we saved a file. This would quickly
//   exhaust the database's connection limit and crash the application.
//
// - The code in this file implements a singleton pattern. It checks if a
//   Prisma Client instance already exists on the "global" object. If it does, it reuses
//   the existing one. If it doesn't, it creates a new one. This ensures that, no matter
//   how many times the code is hot-reloaded, there is only ever one single Prisma Client
//   and one connection to the database.

// This line imports the main `PrismaClient` class from the `@prisma/client` package.
// This package is auto-generated by Prisma every time you run `npx prisma generate`.
// The `PrismaClient` class is the primary, type-safe interface for all database interactions.
import { PrismaClient } from "@prisma/client";

// This line imports the validated and type-safe `env` object from the T3 stack's
// environment variable management system. We will use this to access the `NODE_ENV`
// variable to configure logging differently for development and production.
import { env } from "~/env";

// This defines an arrow function named `createPrismaClient`. Its sole job is to create
// a new instance of the Prisma Client with specific logging configurations.
const createPrismaClient = () =>

  // This line creates a new instance of the Prisma Client.
  // We are calling the constructor of the `PrismaClient` class.
  // It takes an optional configuration object as an argument.
  new PrismaClient({

    // The `log` property allows us to configure what Prisma will log to the console.
    // We are providing a value conditionally using a "ternary operator".
    log:

      // The Condition: `env.NODE_ENV === "development"`
      // This checks if the application is currently running in the development environment.
      // The `?` separates the condition from the "true" case.
      // If we are in development, we provide an array of log levels. Prisma will log:
      // - "query": The actual SQL queries being sent to the database.
      // - "error": Any errors that occur during a database operation.
      // - "warn": Any potential issues or warnings from Prisma.
      // This is extremely useful for debugging during development.
      // The `:` separates the "true" case from the "false" case.
      // If we are in production, we only log errors. We do not want to log every single
      // query in a live production environment as it would be very noisy and could have
      // performance implications.
      env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

// This block of code is the first part of the solution to the "hot reloading" problem.
// Its entire purpose is to create a type-safe way to access a custom property on JavaScript's global object.
//
// `const globalForPrisma = ...`
//   - We are declaring a new constant named `globalForPrisma`. This variable will hold a
//     reference to the global object, but with our custom TypeScript types applied.
//
// `globalThis`
//   -  In any JavaScript environment, there is a single, top-level
//     "global object" that is always present. This object owns all global variables and built-in
//     functions (like `setTimeout` or `console`). You can think of it as the ultimate "root"
//     scope of the entire application.
//   - Historically, accessing this global object was inconsistent. In a web browser,
//     it was called `window`. In Node.js on the server, it was called `global`.
//   - `globalThis` is a modern, standardized variable that is guaranteed
//     to refer to the correct global object, regardless of whether the code is running in a browser,
//     on a server (Node.js), or in any other JavaScript environment.
//
//     During development, when you save a file, Next.js provides a feature called "hot reloading."
//     Instead of restarting the entire server (which is slow), it cleverly re-runs just the modules
//     (files) that have changed. This is great for speed, but it creates a problem for database
//     connections. If the code to create a new Prisma Client were run every time this file is
//     reloaded (on every save), you would quickly create dozens of new database connections,
//     exhausting the database's connection limit and crashing the application.
//
//     The key feature of the global object (`globalThis`) is that it's a singleton. A singleton is
//     an object that is restricted to having only one single instance throughout the entire
//     application's lifecycle. Because this single instance persists across hot reloads (while our
//     module's local variables are re-initialized), it is the perfect place to store our single,
//     persistent Prisma Client instance, thus solving the hot reloading problem.
//
// `as unknown`
//   - This is the first step of a two-part "type assertion" in TypeScript.
//   - By default, TypeScript has a very strict type for `globalThis` and doesn't allow you to just
//     add new properties to it (like `globalThis.prisma = ...`).
//   - The `as unknown` keyword is a way of telling the TypeScript compiler: "Stop. Forget everything
//     you think you know about the type of `globalThis`. For a moment, just treat it as a complete
//     mystery box of type `unknown`. I am about to tell you its true shape."
//   - This is a necessary intermediate step to make a forceful type change.
//
// `as { ... }`
//   - This is the second step of the type assertion. We are now telling TypeScript the new "shape"
//     of this "mystery box". We are asserting, "Treat this value AS if it were an object that
//     matches this specific interface."
//
// `prisma: ... | undefined`
//   - Inside our new object shape, we are declaring that it has a single property named `prisma`.
//   - The `:` begins the type definition for this `prisma` property.
//
// `ReturnType<typeof createPrismaClient>`
//   - This is a complex but powerful TypeScript utility type. Let's break it down from the inside out:
//     - `createPrismaClient`: This is our function that creates a new Prisma Client.
//     - `typeof`: This is a TypeScript operator that gets the "type" of a value. `typeof createPrismaClient`
//       doesn't return `"function"`; it returns the full function signature, including its parameters and what it returns.
//     - `ReturnType<...>`: This is a TypeScript "utility type". It takes a function's type as its input and
//       extracts only the type of the value that the function returns.
//     - In short, `ReturnType<typeof createPrismaClient>` is a very robust way of saying "the exact type of a
//       fully configured Prisma Client instance," without having to manually type it out.
//
// `| undefined`
//   - The `|` is the "union" type operator. It means "OR".
//   - The entire type `... | undefined` means that the `prisma` property can either be a fully-configured
//     Prisma Client instance OR it can be `undefined` (meaning it hasn't been created yet).
const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

// This is the main line that initializes and exports our single, application-wide Prisma Client instance.
// It uses a clever trick with the "nullish coalescing operator" (`??`) to either reuse an
// existing client or create a new one.
//
// Let's break down the statement: `export const db = ...`
// - `export`: This makes the `db` constant available to be imported by any other server-side file in our project.
// - `const db`: We are declaring the constant that will hold our Prisma Client. This `db` variable is what
//   the rest of our application (e.g., tRPC routers) will use to talk to the database.
//
// Now, let's look at the value being assigned: `globalForPrisma.prisma ?? createPrismaClient()`
// - `??`: This is the "nullish coalescing operator". It's a logical operator that checks if the value
//   on its left is "nullish" (meaning `null` or `undefined`).
//   - If the left-hand value is NOT `null` or `undefined`, the operator returns the left-hand value.
//   - If the left-hand value IS `null` or `undefined`, the operator returns the right-hand value.
//
// The Two Scenarios:
//
// 1. First time the server starts: `globalForPrisma.prisma` does not exist yet, so its value is `undefined`.
//    The `??` operator sees this, ignores the left side, and executes the right side: `createPrismaClient()`.
//    A brand new Prisma Client instance is created and assigned to `db`.
//
// 2. After a hot reload: The module's code re-runs. However, because the `if` block at the end of this
//    file ran during the previous execution, `globalForPrisma.prisma` was already set.
//    Now, `globalForPrisma.prisma` HAS a value (it's the existing client instance). The `??` operator
//    sees that the left side is not nullish, so it simply returns that existing instance.
//    `createPrismaClient()` is NOT called again.
export const db = globalForPrisma.prisma ?? createPrismaClient();

// This final block of code is what makes the caching solution work. It saves the Prisma Client
// instance onto the global object so it can be reused on the next hot reload.
//
// `if (env.NODE_ENV !== "production")`: This condition is crucial. The hot-reloading problem that
// we are solving only exists in a development environment. In a production environment, the server
// starts once and the code runs once, so there is no need to cache the client on the global object.
// This `if` statement ensures that this caching logic only ever runs during development.
// If the code is running in a development environment, then
// we take the Prisma Client instance that was just assigned to our `db` constant (whether it was
// newly created or reused from a previous load) and we assign it to the `prisma` property
// on our typed `globalForPrisma` object.
// This "primes the cache" for the next time a hot reload occurs. On the next save, the code at the top
// of this file will run again, but this time `globalForPrisma.prisma` will have a value, and the
// `??` operator will correctly reuse it.
if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;
