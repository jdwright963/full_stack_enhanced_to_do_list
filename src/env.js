/* This file, is automatically generated by `create-t3-app`. The core
 * structure and logic of this file have NOT been modified, but the schemas inside
 * (specifically the `server` object) have been populated with the environment variables
 * required by the specific packages chosen during setup (like NextAuth and Prisma).
 *
 * This file is the heart of the T3 stack's type-safe environment variable management.
 * Its purpose is to use the `@t3-oss/env-nextjs` library, powered by Zod, to:
 *
 * 1. Define a Schema: It requires you to explicitly define a schema for ALL of your
 *    environment variables, specifying their data types (e.g., string, URL) and whether
 *    they are required.
 *
 * 2. Validate at Build Time: The most important feature. This file is imported by
 *    `next.config.js`. This means that when you run `npm run build` or `npm run dev`,
 *    this code runs first. It will check the variables in your `.env` file against the
 *    schema. If any required variable is missing or has the wrong type, the entire
 *    build/dev process will fail immediately with a clear error message.
 *
 * 3. Provide a Type-Safe `env` Object: It exports a fully typed `env` object. When you
 *    use `env.DATABASE_URL` elsewhere in your code, TypeScript knows it's a string and
 *    that it is guaranteed to exist, eliminating an entire class of common runtime errors
 *    that happen in production when an environment variable is forgotten.
 */

// This line imports the main `createEnv` function from the `@t3-oss/env-nextjs` library.
// This library was specifically created by the T3 Stack team to solve the problem of managing
// and validating environment variables in a type-safe way within a Next.js application.
//
// It is a "factory function". Its only job is to take a large configuration object (which contains
// your Zod schemas and runtime environment variables) and process it. It performs the validation
// and, if successful, returns a fully typed, "proxied" `env` object.
//
// A "Proxy" is an advanced JavaScript feature. It allows you to create a special object that
// wraps another object and can intercept fundamental operations, like when you try to get a
// property from it (e.g., `env.DATABASE_URL`).
//
// The `createEnv` function uses a Proxy to add a layer of safety. The returned `env` object
// is a Proxy that contains a special rule: "If a developer tries to access a client-side
// variable (one NOT prefixed with `NEXT_PUBLIC_`) from client-side code, throw an error."
// This prevents you from accidentally leaking server-side secrets to the browser, adding
// a powerful runtime safety check on top of the build-time validation.
import { createEnv } from "@t3-oss/env-nextjs";

// This line imports the main `z` object from the `zod` library.
// Zod is a "schema declaration and validation" library. A "schema" is a blueprint that
// defines the exact shape and data types that a piece of data is expected to have.
// Zod's key feature is that it allows you to define this schema once and then derive
// both a runtime validator AND a static TypeScript type from it.
//
// In a full-stack app, you are constantly dealing with data that crosses boundaries,
// like an API request from a user or an environment variable from a `.env` file. At these
// boundaries, you lose TypeScript's guarantees. You might expect a variable to be a
// string, but it could be `undefined`. Zod is the "bouncer at the door" that validates
// this "untrusted" data at runtime to ensure it matches the shape your application expects.
//
// The `z` object is the entry point for building these schemas. You "chain" methods
// together to create a set of rules. For example, let's look at a schema from this file:
// `z.string().url()`
//
// - `z`: The main Zod object.
// - `.string()`: This is the "base schema". It declares a rule: "This data must be a string."
//   It cannot be a number, an object, or `undefined`.
// - `.url()`: This is a "chained refinement". It adds an additional rule on top of the first
//   one: "And by the way, this string must also be formatted like a valid URL."
//
// Other common chains are `.min(1)` (must not be an empty string) or `.optional()`
// (the variable is allowed to be `undefined`).
//
// The `createEnv` function takes these Zod schemas and uses them as the "rulebook" to
// validate the actual environment variables loaded from the `.env` file, catching
// any configuration errors before the application even starts.
import { z } from "zod";

// This line creates and exports the main `env` object that the rest of the application will import and use.
// `export const env = ...`: We are creating a constant named `env` and exporting it so it can be used globally.
// `createEnv({...})`: We are calling the `createEnv` factory function that we imported.
// The single, large object passed to this function is the main configuration object that defines all the validation rules.
export const env = createEnv({

  // This `server` property is an object that contains the Zod schemas for all of your server-side environment variables.
  // These are variables that are ONLY available in the Node.js runtime on the server. They are never,
  // under any circumstances, sent to the user's browser. This is where you put all your secrets, like
  // database URLs, API keys, and private tokens. The `@t3-oss/env-nextjs` library has a built-in
  // safety mechanism (a Proxy) that will throw a runtime error if you accidentally try to access
  // one of these variables from client-side code.
  server: {

    // This defines the validation rule for the `AUTH_SECRET` environment variable.
    // `AUTH_SECRET`: This key must exactly match the variable name in the `.env` file.
    AUTH_SECRET:

      // This is a "ternary operator" (`condition ? value_if_true : value_if_false`).
      // It is used here to define a conditional Zod schema. The validation rule for `AUTH_SECRET`
      // will be different depending on whether the application is in production or development.
      //
      // The Condition: `process.env.NODE_ENV === "production"`
      //   - This checks if the `NODE_ENV` environment variable is strictly equal to the string "production".
      //   - This is the standard way to determine if the application is running in a live, deployed environment.
      process.env.NODE_ENV === "production"

        // The `?` separates the condition from the "value if true" part.
        // If the app is in production, the schema for `AUTH_SECRET` is `z.string()`.
        // `z.string()`: This Zod schema dictates a strict rule: the `AUTH_SECRET` environment
        // variable MUST exist and its value must be of the type `string`.
        // NOTE: By itself, `z.string()` does allow an empty string (`""`). This is restricted at the bottom of this file.
        ? z.string()

        // The `:` separates the "value if true" from the "value if false" part.
        // If the app is not in production, the schema for `AUTH_SECRET` is `z.string().optional()`.
        // `z.string().optional()`: The `.optional()` is a "modifier" that is chained onto the base `z.string()` schema.
        // It changes the rule to be: "If the `AUTH_SECRET` environment variable exists, it must be a string.
        // However, if it does not exist at all, that is also perfectly acceptable."
        // For some authentication providers, a secret might not be strictly necessary
        // for local development, so this allows the app to run without it, while still enforcing its presence in production.
        : z.string().optional(),

    // This defines the validation rule for the `AUTH_DISCORD_ID` environment variable.
    // `AUTH_DISCORD_ID`: The key must match the variable name in the `.env` file.
    // `z.string()`: This is the Zod schema. It enforces that the `AUTH_DISCORD_ID` variable MUST exist
    // and its value MUST be a string in all environments (development and production). The app will not
    // build or start if this variable is missing.
    AUTH_DISCORD_ID: z.string(),

    // This defines the validation rule for the `AUTH_DISCORD_SECRET` environment variable.
    // `z.string()`: Similar to the ID, this schema enforces that the Discord client secret MUST
    // always exist and be a string.
    AUTH_DISCORD_SECRET: z.string(),

    // 1. `.string()`: The variable must exist and its value must be a string.
    // 2. `.url()`: This is a "refinement". It adds a second layer of validation, checking that the
    //    string is also formatted as a valid URL. This would catch typos like `post gresql://...`.
    // The app will not build or start if this variable is missing or is not a valid URL.
    DATABASE_URL: z.string().url(),

    // This defines the validation rule for the `NODE_ENV` environment variable, which specifies the environment in which the application is running.
    // `NODE_ENV` is a standard convention in Node.js that determines the runtime environment, with common values being "development", "test", and "production".
    // By validating this variable, we ensure it's set to one of the expected values, which is crucial for configuring logging, debugging, and other environment-specific behaviors.
    NODE_ENV: z

      // `z.enum([...])`: This schema creates a strict "enum" type. It dictates that the value
      // of `NODE_ENV` MUST be one of the exact strings provided in the array: "development",
      // "test", or "production". Any other value will cause a validation error.
      .enum(["development", "test", "production"])

      // `.default("development")`: This is a modifier that provides a default value.
      // If the `NODE_ENV` environment variable is not set at all, Zod will not throw an error.
      // Instead, it will use the default value `"development"` for this variable. This is useful for
      // ensuring a sensible default when running the app in a simple local environment.
      .default("development"),

    // SMTP and email settings: these variables configure the application's email sending capabilities.
    // They define the SMTP server host, port, authentication credentials, and the sender's email address.
    // Note that EMAIL_FROM is validated to ensure it conforms to a standard email address format.
    SMTP_HOST: z.string(),
    SMTP_PORT: z.string(),
    SMTP_USER: z.string(),
    SMTP_PASS: z.string(),
    EMAIL_FROM: z.string().email(),
  },

  // This `client` property is an object that contains the Zod schemas for all of your client-side environment variables.
  // These are variables that are specifically intended to be available in the user's browser. They are
  // "public" and should NEVER contain secrets. A common use case is a public API key for a service
  // like Google Maps, or the public URL of your application.
  //
  // To prevent accidentally leaking server-side secrets, Next.js has a strict rule: only environment
  // variables that start with the prefix `NEXT_PUBLIC_` will ever be bundled and sent to the browser.
  // The `@t3-oss/env-nextjs` library enforces this rule.
  client: {

    // This is a commented-out example of how you would define a client-side variable.
    // To use it, you would uncomment it, add `NEXT_PUBLIC_CLIENTVAR="some_value"` to your `.env` file,
    // and also add it to the `runtimeEnv` object below.
    // NEXT_PUBLIC_CLIENTVAR: z.string(),

    // The publicly accessible URL of the application, validated to ensure it's a properly formatted URL.
    NEXT_PUBLIC_APP_URL: z.string().url(),

  },

  // The `runtimeEnv` object is the most critical piece of the validation puzzle.
  //
  // 1.  Node.js is a JavaScript "runtime environment". It's a program that allows you to execute JavaScript
  //    code outside of a web browser, for example, on a server. In any Node.js application, `process` is a 
  //    global object that provides information about the current running process.
  //
  // 2. The Next.js application is a sophisticated Node.js application. When you run `npm run dev` or 
  //    `npm start`, you are starting a Node.js server that is running the Next.js framework. All of 
  //     your "server-side" code (in `src/server`, API routes, and Server Components) is executed by 
  //     this Node.js process.
  //
  // 3. The `process.env` Object: Because the server code runs in Node.js, it has access to the
  //    `process` object. The `.env` property on this object (`process.env`) is a special object that
  //    contains all the "environment variables" that were available to the application when it started.
  //    Next.js automatically loads variables from your `.env` file into `process.env` for you.
  //
  // 4. The user's web browser is a completely separate environment. It does not have a `process` object.
  //    The client-side JavaScript code that runs in the browser cannot directly access `process.env`.
  //
  // This `runtimeEnv` object's job is to provide the actual, live values from the server's
  // `process.env` that will be validated against the `server` and `client` schemas you defined above.
  //
  // Why is this necessary?
  // The `createEnv` function needs to know two things:
  // 1. The "rules" (your Zod schemas in `server` and `client`).
  // 2. The "data" to check against those rules.
  // This `runtimeEnv` object provides that "data".

  /**
   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.
   * middlewares) or client-side so we need to destruct manually.
   */
  runtimeEnv: {
    AUTH_SECRET: process.env.AUTH_SECRET,
    AUTH_DISCORD_ID: process.env.AUTH_DISCORD_ID,
    AUTH_DISCORD_SECRET: process.env.AUTH_DISCORD_SECRET,
    DATABASE_URL: process.env.DATABASE_URL,
    NODE_ENV: process.env.NODE_ENV,
    SMTP_HOST: process.env.SMTP_HOST,
    SMTP_PORT: process.env.SMTP_PORT,
    SMTP_USER: process.env.SMTP_USER,
    SMTP_PASS: process.env.SMTP_PASS,
    EMAIL_FROM: process.env.EMAIL_FROM,
    NEXT_PUBLIC_APP_URL: process.env.NEXT_PUBLIC_APP_URL,

  },

  // This property provides an "escape hatch" to disable the entire validation process.
  // The value is a boolean (`true` or `false`).
  //
  // Let's break down how its value is determined: `!!process.env.SKIP_ENV_VALIDATION`
  // 1. `process.env.SKIP_ENV_VALIDATION`: This reads an environment variable named `SKIP_ENV_VALIDATION`.
  //    If you run `SKIP_ENV_VALIDATION=true npm run build`, this variable will be the string "true". If you
  //    don't set it, the variable will be `undefined`.
  // 2. `!`: The first `!` is a logical NOT operator. It converts the value to a boolean and then inverts it.
  //    - If the variable is "true" (a "truthy" value), `!variable` becomes `false`.
  //    - If the variable is `undefined` (a "falsy" value), `!variable` becomes `true`.
  // 3. `!!`: The second `!` inverts the boolean again.
  //    - If the variable was "true", `!variable` is `false`, and `!!variable` becomes `true`.
  //    - If the variable was `undefined`, `!variable` is `true`, and `!!variable` becomes `false`.
  // This `!!` pattern is a common JavaScript trick to convert any value into its strict boolean equivalent.

  /**
   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially
   * useful for Docker builds.
   */
  skipValidation: !!process.env.SKIP_ENV_VALIDATION,

    // This property toggles a stricter validation rule for string schemas.
  // By default in Zod, `z.string()` considers an empty string (`""`) to be a valid string.
  // However, in the context of environment variables, an empty string is almost always a mistake
  // (e.g., `DATABASE_URL=""`).
  //
  // When `emptyStringAsUndefined` is set to `true`:
  // The library will first check if any environment variable's value is an empty string. If it is,
  // it will treat that variable as if it were `undefined` before passing it to Zod for validation.
  //
  // This has a critical effect:
  // - A schema like `DATABASE_URL: z.string()` will now FAIL if `DATABASE_URL=""` is in your `.env` file,
  //   because the empty string becomes `undefined`, and `z.string()` does not allow `undefined`.
  // - This forces you to be more explicit. To allow an empty string, you would need to define the schema
  //   as `z.string().optional()` or provide a default value.

  /**
   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and
   * `SOME_VAR=''` will throw an error.
   */
  emptyStringAsUndefined: true,
});
