/* This file is automatically generated by `create-t3-app`.
 * It serves as the central configuration and setup hub for the client-side tRPC and
 * React Query integration. This file has NOT been modified from its default state.
 *
 * Its main responsibilities are:
 * 1. To create the main, type-safe `api` object. This is the primary "client" that is
 *    imported into components to make API calls (e.g., `api.task.getAll.useQuery()`).
 * 2. To define a "singleton" pattern for the `QueryClient`. This ensures that in the browser,
 *    there is only ever one single instance of the React Query cache, which is essential
 *    for a consistent application state.
 * 3. To create the `<TRPCReactProvider>` component. This is the main Context Provider that
 *    wraps the entire application in `layout.tsx`. It's responsible for initializing the
 *    tRPC client and making both the tRPC client and the QueryClient available to the rest of the app.
 * 4. To export useful TypeScript "inference helpers" (`RouterInputs`, `RouterOutputs`) that
 *    allow you to easily get the TypeScript types for your API's inputs and outputs.
 */

// This directive is essential. It marks this file as a "Client Component" module.
// This means any component exported from this file (specifically `TRPCReactProvider`)
// can be used in other Client Components and can use client-side features like hooks (`useState`).
"use client";

// This line imports key components and types from `@tanstack/react-query`.
// `QueryClientProvider`: This is the main Context Provider from the React Query library.
// When it wraps your application, it makes the central `QueryClient` instance (the data cache)
// available to all components that use React Query hooks (which tRPC's hooks do).
//
// What does it mean to "wrap your application" with a Provider?
// In React, a Provider is a special component that you place at a high level in your component tree,
// typically in a root file like `layout.tsx`. You "wrap" your application by making all of your
// other pages and components its `children`.
//
// Like this in `layout.tsx`:
// <QueryClientProvider client={myQueryClient}>
//   {/* All of your other components go here */}
// </QueryClientProvider>
//
// By doing this, the `QueryClientProvider` makes a single, central `QueryClient` instance (the data cache)
// available to EVERY component nested inside it. Any component can then "hook into" this provider
// to access the cached data. This is what allows different components across your app to share the
// same data without having to pass it down manually as props.
//
// `type QueryClient`: This imports the TypeScript "type" definition for a `QueryClient` instance.
// We use this for type-safety when defining our singleton.
import { QueryClientProvider, type QueryClient } from "@tanstack/react-query";

// This line imports two "links" from the tRPC client library.
// What is a tRPC Link? A link is a piece of middleware.Middleware is code that "sits in the middle" of a
// request/response cycle to intercept and modify the operation. Think of it like a series
// of checkpoints on a road. Each checkpoint (link) can inspect the car (the tRPC request),
// log its details, or even turn it around before it reaches its final destination. You can
// chain multiple links together to build a custom processing pipeline.
// 
// `httpBatchStreamLink`: This is the link that actually makes the HTTP request to the backend.
// - "Batching": A powerful performance optimization. If multiple queries are made in a very
//   short time, this link groups them into a single HTTP request, reducing network traffic.
// - "Streaming": For advanced use cases, tRPC can "stream" responses, meaning it can send
//   back data in chunks as it becomes available, rather than waiting for the entire response
//   to be ready. This can improve the perceived performance of your application.
//
// `loggerLink`: A helpful link for development. It acts as a "checkpoint" that intercepts
// every tRPC operation and logs its details (inputs, outputs, timing) to your browser's
// developer console, which is incredibly useful for debugging.
import { httpBatchStreamLink, loggerLink } from "@trpc/client";

// This imports the main factory function responsible for creating the entire client-side tRPC system for React.
// `createTRPCReact`: This function acts as the central bridge connecting three distinct worlds:
// 1. Your tRPC API's "shape" (defined on the backend).
// 2. The React Query library (for data fetching and caching).
// 3. The React framework itself (for building the user interface).
//
// You call this function once to create the main `api` object. This object becomes the primary
// interface your components will use to interact with the backend. It is populated with a custom,
// type-safe "hook system" that is perfectly tailored to your API's structure.
//
// What is the difference between a React Hook and a tRPC Hook:
//
//   - React Hook (e.g., `useState`, `useEffect`):
//     A "hook" is a special function in React (always starting with `use...`) that lets a component
//     "hook into" the core features of the React library itself. React is the underlying UI
//     framework responsible for rendering components, managing state, and tracking component lifecycles.
//     `useState`, for example, hooks into React's internal state management system.
//
//   - tRPC React Query Hook (e.g., `api.task.getAll.useQuery()`):
//     This is a custom hook that is built on top of the React Query library, but made available
//     through the tRPC `api` object. It is NOT part of the core React library. Its purpose is to
//     provide a simple way to "hook into" the external data fetching and caching logic provided by
//     the `QueryClient`. When you call `api.task.getAll.useQuery()`, you are
//     telling React Query to manage the entire lifecycle of that specific data fetch, and tRPC ensures
//     this entire process is end-to-end type-safe.
//
// The `createTRPCReact` function is what generates this collection of custom tRPC React Query hooks.
import { createTRPCReact } from "@trpc/react-query";

// This line imports two special "type inference" utilities directly from the core tRPC server library.
// These are not runnable code; they are powerful, TypeScript-only tools that act like "type generators".
// Their purpose is to look at your backend API router (`AppRouter`) and automatically create TypeScript
// types that perfectly match the inputs and outputs of every single one of your API procedures.
//
// Imagine you have a tRPC procedure on your backend defined like this:
// `task.create: protectedProcedure.input(z.object({ title: z.string(), dueDate: z.date().optional() })).mutation(...)`
//
// Now, on your frontend, you want to create a variable that can hold the input for this procedure.
// Without these helpers, you would have to manually re-define the type in your frontend code:
// `type MyTaskInput = { title: string; dueDate?: Date; }`
// This is bad because if you ever change the backend validation (e.g., make `dueDate` required),
// you would have to remember to manually update the frontend type, or you would introduce a bug.
//
// The Solution (`inferRouterInputs` and `inferRouterOutputs`):
// These helpers automate the process. By using them later in this file to create the `RouterInputs`
// and `RouterOutputs` types, we can get the exact, up-to-date type for any procedure directly
// from the router itself, like this:
// `type MyTaskInput = RouterInputs['task']['create'];`
//
// Now, if you change the backend Zod schema, this `MyTaskInput` type on the frontend will
// automatically update, and TypeScript will immediately show you an error anywhere your
// frontend code is no longer correct. This eliminates an entire class of bugs and makes
// the codebase incredibly robust and easy to refactor.
//
// - `type inferRouterInputs`: The generic type used to generate the `RouterInputs` helper.
// - `type inferRouterOutputs`: The generic type used to generate the `RouterOutputs` helper.
import { type inferRouterInputs, type inferRouterOutputs } from "@trpc/server";

// Imports the `useState` hook from the React library itself.
// A "hook" is a special function (always starting with `use...`) that lets a function component
// "hook into" React's core features. `useState` is the most fundamental hook. It allows a
// component to have "state" â€” a variable whose value persists between renders and whose changes
// will automatically trigger a re-render of the component's UI.
import { useState } from "react";

// Imports the `SuperJSON` library, which is a critical part of the T3 stack's data flow.
// Standard JSON, which is used to send data over the internet,
// has limitations. It cannot properly handle complex JavaScript data types like `Date`. 
// These types are either converted into plain strings or lost entirely,
// breaking type-safety.
//
// `SuperJSON` is a library that extends JSON. It serializes these complex types into a special
// string format that includes their type information. On the other end, it can deserialize this
// string back into the original, correct JavaScript object. We use it in our tRPC "links" to
// ensure that a `Date` object from our server arrives as a real `Date` object in our client.
import SuperJSON from "superjson";

// This line imports the main `AppRouter` type from our backend's root API file.
//
// 1. `import type { ... }`:
//    - The `import type` statement is a specific TypeScript feature. It's a signal to the compiler
//      that we are ONLY importing a type definition (`AppRouter`), not any runnable JavaScript code.
//
// 2. `AppRouter`:
//    - This is NOT an object or a function. It is a TypeScript `type` alias.
//    - It is created in `~/server/api/root.ts` with the line:
//      `export type AppRouter = typeof appRouter;`
//    - The `typeof` operator inspects the actual `appRouter` object (which
//      contains all your procedures like `post.hello` and `task.create`) and generates a
//      massive, detailed TypeScript type that perfectly describes its entire structure. This
//      `AppRouter` type contains information about every router, every procedure, the exact
//      `input` type for each procedure (from Zod), and the exact `output` (return) type.
//
// 3. The `~/` is a path alias that points to the `src` directory, configured in `tsconfig.json`.
//
// The entire T3 developer experience hinges on this line. Later in this file, we will create our
// main `api` client like this: `export const api = createTRPCReact<AppRouter>();`.
//
// - By passing `<AppRouter>` as a "generic type" to `createTRPCReact`, we are giving our client-side
//   setup a perfect, static "blueprint" of the entire backend API.
//
// - The `createTRPCReact` function uses this blueprint to auto-generate a fully typed `api` object.
//
// - This means when you type `api.task.create.mutate(` on the frontend, your code editor:
//   a) Knows that `.task` exists.
//   b) Knows that `.create` exists within `.task`.
//   c) Knows that the `.mutate` function for `.create` expects a specific input object (e.g., `{ name: string }`).
//   d) Knows that the `data` returned from a query like `api.task.getAll.useQuery()` will be an array of tasks.
//
// This is how a change on the backend (e.g., changing an input in a Zod schema) can immediately cause a
// TypeScript error on the frontend, catching bugs before they ever happen.
import { type AppRouter } from "~/server/api/root";

// This line imports the `createQueryClient` "factory function" for creating a `QueryClient` instance.
// It is used here to create the client-side instance, and it's also used in `~/trpc/server.ts`
// to create the server-side instance. Using this single factory guarantees that both environments
// share the exact same configuration, which is essential for the hydration process to work correctly.
import { createQueryClient } from "./query-client";

// This line declares a module-level variable that will store our single, persistent QueryClient instance for the browser.
//
// - `let`: We use `let` instead of `const` because the value of this variable will be reassigned exactly once,
//   from its initial state of `undefined` to the actual `QueryClient` instance the first time it's needed.
// - `clientQueryClientSingleton`: The descriptive name makes its purpose clear. A "singleton" is a design
//   pattern that restricts an object to only one single instance across an entire application.
// - `: QueryClient | undefined`: This is a TypeScript "union type". It declares that this variable can
//   hold one of two possible types: either a full `QueryClient` object OR the value `undefined`.
// - `= undefined`: We explicitly initialize the variable to `undefined`. This represents the initial
//   state where the client-side `QueryClient` has not yet been created.
let clientQueryClientSingleton: QueryClient | undefined = undefined;

// This defines a "getter" function. Instead of accessing the singleton variable directly, the rest of our
// code will call this function. This function's job is to encapsulate the logic for either returning
// the existing instance or creating a new one if it doesn't exist yet, depending on the environment.
const getQueryClient = () => {

  // This `if` statement is the crucial environment check. Its purpose is to determine if the code is
  // currently running on the server (during server-side rendering) or in the client's browser.
  //
  // - `window`: This is the global object that exists ONLY in a web browser environment. It contains all
  //   the browser APIs like `document`, `location`, etc.
  // - `typeof window`: This is a safe way to check for its existence.
  //   - In a browser: `window` is an object, so `typeof window` will return the string `"object"`.
  //   - On the server (Node.js): The `window` object does not exist. Trying to access a non-existent
  //     variable would normally throw an error, but the `typeof` operator is special. It will safely
  //     return the string `"undefined"` instead of crashing.
  if (typeof window === "undefined") {

    // The code inside this `if` block is executed ONLY when the function is running on the server.
    
    // This comment from the T3 boilerplate summarizes the server-side strategy:
    // "Server: always make a new query client"
    
    // We call our `createQueryClient` factory function and immediately return the new instance.
    // Why create a NEW client every time on the server:
    // This is a critical architectural decision for data safety and isolation. Every incoming
    // request to your server (from different users, or even different browser tabs from the same user)
    // is a separate, isolated event. If we were to reuse the same QueryClient instance across
    // different user requests on the server, there would be a risk of one user's cached data
    // accidentally "leaking" and being shown to another user. By creating a fresh, new
    // `QueryClient` for every single request, we guarantee that each user's data fetching
    // process is completely isolated and secure.
    return createQueryClient();
  }

  // The code below this point is executed ONLY when the function is running in the user's browser.
  
  // This comment from the T3 boilerplate summarizes the client-side strategy:
  // "Browser: use singleton pattern to keep the same query client"
  
  // This line ensures that the `createQueryClient()` factory is called only ONCE for the entire lifecycle of the application in the browser.
  //
  // The line `a ??= b` is the equivalent of writing this:
  // `if (a === null || a === undefined) { a = b; }`
  //
  // 1. The first time this runs the `clientQueryClientSingleton` variable is `undefined`. The `??=`
  //    operator checks this, finds that it is "nullish", and executes the code on the right side.
  //    It calls `createQueryClient()`, which creates a new `QueryClient` instance. This new instance
  //    is then assigned back to the `clientQueryClientSingleton` variable.
  //
  // 2. On any subsequent call to `getQueryClient` (e.g., from a different
  //    component or a re-render), the `clientQueryClientSingleton` variable now holds the `QueryClient`
  //    instance created in the first step. The `??=` operator checks it, finds that it is NOT nullish,
  //    and does nothing. The code on the right side is NOT executed.
  //
  // This guarantees we have one single, persistent QueryClient for the user's entire session in their browser tab.
  clientQueryClientSingleton ??= createQueryClient();

  // This line returns the `clientQueryClientSingleton` variable.
  // Thanks to the logic above, we can be 100% certain that by the time this line is reached,
  // the variable holds the one and only instance of our `QueryClient` for the browser.
  return clientQueryClientSingleton;
};

// Creates the main tRPC client for the frontend using the AppRouter type from the backend.
// The resulting `api` object provides type-safe React Query hooks (e.g., api.task.getAll.useQuery()).
export const api = createTRPCReact<AppRouter>();

// This line creates and exports a TypeScript "helper type" named `RouterInputs`.
// This is not runnable code; it's a powerful tool for your development experience that
// allows you to easily get the exact TypeScript types for the inputs of any of
// your API procedures without defining them manually.
//
// 1. `export type RouterInputs = ...`: This syntax creates and exports a "Type Alias".
//    A type alias is a feature in TypeScript that allows you to create a new, custom name for
//    another type. It doesn't create a new type, but rather a "nickname" or "shortcut" for
//    an existing one. This is incredibly useful for making complex types (like the ones
//    generated by tRPC) easier to read and reuse. Here, we are creating a new name, `RouterInputs`,
//    for the complex type that is generated on the right-hand side of the `=`.
//
// 2. `inferRouterInputs<AppRouter>`: This is the tRPC "inference helper" that generates the complex type.
//    - `inferRouterInputs`: This is a powerful "generic type" provided by tRPC. Its job is to
//      programmatically inspect an API router's shape.
//    - `<AppRouter>`: We pass it our API's complete "blueprint" (`AppRouter`).
//
// The `inferRouterInputs<AppRouter>` utility analyzes your entire backend API and generates a
// single, massive, nested object type. This type maps out the exact input shape for every single
// procedure. The `RouterInputs` alias now holds this generated type.
//
// Imagine your backend has a procedure `task.create` that takes an input like `{ title: string }`.
// In your frontend code, you can now use the `RouterInputs` alias to access the type for that specific input:
// `type MyCreateTaskInput = RouterInputs['task']['create'];`
//
// TypeScript will now understand that `MyCreateTaskInput` is exactly `{ title: string }`. If you ever
// change the backend input schema, this `MyCreateTaskInput` type will automatically update. This
// is the core of tRPC's end-to-end type safety, as it eliminates the need to manually keep
// frontend and backend types in sync.

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

// This line creates and exports another TypeScript "type alias" named `RouterOutputs`.
//
// It works in the exact same way as `RouterInputs` above, but it's for the return values (outputs)
// of your API procedures. It uses the `inferRouterOutputs` helper to inspect your `AppRouter`
// and generate a type that maps out the exact shape of the data returned by every procedure.
//
// Example Usage:
// `type MyTask = RouterOutputs['task']['getById'];`
// This would give you the exact type of the task object returned from that specific API endpoint.

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;

// This defines and exports a React "Function Component" that will act as the main Context Provider
// for our entire tRPC and React Query setup. This is the component that will be used in `layout.tsx`
// to wrap the entire application, making all data-fetching capabilities available globally.
//
// `(props: { children: React.ReactNode })`: The component is defined to accept a `props` object.
// - `props`: The object containing all properties passed to the component.
// - `{ children: React.ReactNode }`: This is the TypeScript type for the props object. It specifies
//   that this component must receive a `children` prop, which can be any valid React content. This is
//   what allows it to act as a wrapper around other components.
export function TRPCReactProvider(props: { children: React.ReactNode }) {

  // This line calls the `getQueryClient` function that we defined earlier in this file.
  // This function's logic ensures that we get the single, persistent, singleton instance of the
  // `QueryClient` (the data cache "brain") when running in the browser.
  const queryClient = getQueryClient();

  // This line uses React's `useState` hook to create and store the tRPC client instance.
  // The syntax `const [trpcClient] = ...` might look strange, so let's break it down.
  // It's a combination of how `useState` works and a JavaScript feature called "Array Destructuring".
  //
  // --- Part 1: What `useState` Returns ---
  // The `useState` hook in React does NOT return a single value. It *always* returns an array
  // containing exactly two items:
  //
  // 1. The current state value. (In our case, the `trpcClient` object).
  // 2. A function to update that value. (Conventionally named `setTrpcClient`).
  //
  // So, the result of `useState(...)` is an array like: `[ theClientObject, aFunctionToUpdateIt ]`
  //
  // --- Part 2: "Array Destructuring" (The Brackets) ---
  // The `[...]` syntax is a modern JavaScript shortcut for pulling items out of an array.
  //
  // Without this shortcut, we would have to write the code like this (the "long way"):
  //
  //   const stateArray = useState(() => ...); // stateArray is now an array of 2 items
  //   const trpcClient = stateArray[0];      // Get the first item (the client object)
  //   const setTrpcClient = stateArray[1];   // Get the second item (the update function)
  //
  // The destructuring syntax lets us do all of that in one clean line:
  //
  //   const [trpcClient, setTrpcClient] = useState(() => ...);
  //
  // This is the exact same result as the "long way" above.
  //
  // --- Part 3: Why We Only Have `[trpcClient]` ---
  // In our specific case, the tRPC client is designed to be created ONCE and NEVER change for the
  // entire lifetime of the application. We will never need to call a function to update it.
  //
  // Because we don't need the second item from the array (the `setTrpcClient` function),
  // we can simply omit it from the destructuring assignment. We are telling JavaScript:
  // "I know `useState` returns an array of two things, but I only care about the first one.
  // Please give me the first item and name it `trpcClient`, and you can just ignore the second one."
  const [trpcClient] = useState(() =>

    // This is the function call that is executed only once to create the client.
    // `api.createClient` is the method on our main `api` object (created by `createTRPCReact`)
    // that actually constructs the tRPC client instance. It takes a single configuration object.
    api.createClient({

      // The `links` array defines the client-side middleware pipeline for every tRPC request.
      // Think of it as an assembly line or a series of checkpoints that a request goes through
      // before being sent to the server. The links are executed in the order they appear in this array.
      links: [

        // This is the first link in the chain.
        // Its sole purpose is for development and debugging. It intercepts every tRPC operation
        // (both outgoing requests and incoming responses) and logs detailed information about them
        // to your browser's developer console. It's incredibly useful for seeing the exact
        // inputs, outputs, and timing of the API calls.
        // `loggerLink` is a function that takes a single configuration object.
        loggerLink({

          // The `enabled` property controls whether the logger is active for a given operation.
          // Instead of a simple `true` or `false`, we provide a function. This allows for powerful,
          // dynamic, and conditional logging. tRPC will call this function for each operation,
          // and only if the function returns `true` will the logs be printed.
          //
          // Let's break down the function signature and its logic:
          //
          // 1. `(op) => { ... }`: This is an arrow function that receives a single argument, `op`.
          //
          // 2. `op`: This is a rich object representing the tRPC "operation" itself. It contains
          //    all the context about the current API call, such as:
          //    - `op.path`: The name of the procedure being called (e.g., "task.getAll").
          //    - `op.type`: The type of operation ("query", "mutation", or "subscription").
          //    - `op.direction`: A crucial property that tells us if the operation is "outgoing"
          //      (a request being sent "up" to the server) or "incoming" (a response coming "down"
          //      from the server).
          //    - `op.result`: For incoming ("down") operations, this contains the data or the error
          //      that was returned from the server.
          enabled: (op) =>

          // This line defines the logic for when the logger should be active. The logger is enabled if
          // EITHER the left side OR the right side of the `||` operator is true.
          //
          // --- Part 1: The Development Check ---
          // `process.env.NODE_ENV === "development"`:
          // This is the primary condition. It checks the standard Node.js environment variable. When you
          // run your app with `npm run dev`, Next.js sets this to `"development"`.
          // This means: "In development, log EVERYTHING." This is incredibly useful for debugging.
            process.env.NODE_ENV === "development" ||

            // --- Part 2: The Production Error Check ---
            // This entire block is a secondary condition that ONLY matters in production. It allows
            // us to see critical errors in our production logs without cluttering them with every
            // successful API call.
            // The `&&` means BOTH of these must be true:
            //
            // a) `op.direction === "down"`: The operation is a response coming "down" from the server.
            //
            // b) `op.result instanceof Error`: The result of that response is a JavaScript `Error` object.
            //
            // In plain English, this condition means: "In production, ONLY log operations that are
            // failed responses coming back from the server."
            (op.direction === "down" && op.result instanceof Error),
        }),

        // This is the "terminating" link. It's the last and most important one in the chain because
        // it's responsible for actually sending the HTTP request to your backend. All other links
        // (like `loggerLink`) are just middleware that run before this one.
        // It takes a single configuration object to define how it should make the request.
        httpBatchStreamLink({

          // This property tells the HTTP link how to serialize and deserialize the data being sent.
          // By providing `SuperJSON`, we ensure that complex data types (like `Date`, `Map`, etc.)
          // are correctly converted to a string before being sent and then correctly parsed back
          // into their original types when the response is received. Without this, a `Date` object
          // would just become a plain string, losing its type information.
          transformer: SuperJSON,

          // This property defines the absolute URL of your tRPC API endpoint.
          // `getBaseUrl()`: This is a helper function (defined at the bottom of the file) that
          // dynamically determines the base URL of your application (e.g., `http://localhost:3000`
          // in development or `https://yourapp.com` in production).
          // `+ "/api/trpc"`: We then append the fixed path to the tRPC catch-all route, creating
          // the full, correct URL for the API request.
          url: getBaseUrl() + "/api/trpc",

          // This property configures the HTTP headers that will be sent with every tRPC request.

          // Instead of a static object, `headers` is a function: `() => { ... }`.
          // This is a powerful pattern because this function is executed *just before* every tRPC
          // request is sent. This allows us to dynamically add headers that might change over
          // time or depend on the current application state. The most common use for this is
          // to add a dynamic authentication token (e.g., a JWT) to every request.
          headers: () => {

            // This line creates a new, empty `Headers` object.
            // The `Headers` interface is a standard Web API, the same one used by the native browser
            // `fetch()` function. It provides a convenient and standardized way to work with
            // HTTP headers, using methods like `.set()`, `.get()`, and `.append()`.
            const headers = new Headers();

            // This is the core logic of our function. We are adding a single, custom header to our request.
            // `headers.set(key, value)`: This method sets a header with a specific key and value. If a
            // header with this key already exists, its value is overwritten.
            //
            // - The Key (`"x-trpc-source"`): This is the name of our custom header.
            //   - The `x-` prefix is a long-standing (though no longer required) convention for non-standard,
            //     application-specific headers.
            //   - `"trpc-source"` clearly indicates the header's purpose: to identify the source of the tRPC request.
            //
            // - The Value (`"nextjs-react"`): This is the "label" or "flag" we are assigning.
            //
            // The purpose of this entire line is to "tag" every outgoing tRPC request with information
            // about where it came from. This can be incredibly useful for server-side logging, debugging,
            // or even analytics, as the server can inspect this header to know that the request originated
            // from this specific Next.js React client.
            headers.set("x-trpc-source", "nextjs-react");

            // Finally, the function returns the populated `Headers` object. tRPC will then take this
            // object and attach these headers to the actual outgoing HTTP `fetch` request that gets
            // sent to the server.
            return headers;
          },
        }),
      ],
    }),
  );

  // The `return` statement specifies the JSX that this provider component will render.
  // The structure here is a set of "nested providers," a fundamental pattern in React's
  // Context API for making data and functions available to a deep tree of child components
  // without having to pass them down manually as props.
  //
  // The order of nesting is critical: child providers can depend on the context of parent providers.
  return (

    // This is the top-level provider from the React Query library. Its sole purpose is to make the
    // `queryClient` instance (the central data cache) available via React Context to any
    // component that needs it. tRPC's hooks are built on top of React Query's hooks, so they
    // need access to this context. Therefore, this provider must be on the outside.
    <QueryClientProvider client={queryClient}>

      {/* This is the tRPC-specific provider, which is generated by the `api` object. It must be
          nested inside `QueryClientProvider` because it depends on the React Query context.
          This provider's job is to make two things available to its child components:
          1. The `trpcClient`: The actual client instance configured to talk to your backend.
          2. The `queryClient`: The same data cache instance from the provider above, explicitly
             linking the two systems.
      */}
      <api.Provider client={trpcClient} queryClient={queryClient}>

            {/* This `props.children` represents the rest of the application. By placing it here,
            we ensure that every single page and component is a descendant of both providers.
            This allows any client component in the app to use tRPC hooks (like `api.task.getAll.useQuery()`),
            which will automatically find and use the `trpcClient` and `queryClient` instances
            provided here. */}
        {props.children}  
      </api.Provider>
    </QueryClientProvider>
  );
}

// This is a helper function whose sole purpose is to determine the correct, absolute base URL
// of the application. This is necessary because the URL is different depending on whether the
// code is running in a browser, on a Vercel deployment, or in a local development environment.
// The function uses a cascading "if-else" logic, returning the first value it successfully finds.
function getBaseUrl() {

  // `typeof window !== "undefined"`: This is a reliable, universal check to see if the code
  // is currently executing in a client-side browser environment. The `window` object is a global
  // that only exists in browsers. If it exists, we know we are on the client.
  if (typeof window !== "undefined") 
    
    // If we are in the browser, the most reliable way to get the current URL is to use the
    // `window.location.origin` property. This will return the full base URL, including the
    // protocol, hostname, and port (e.g., "https://yourapp.com" or "http://localhost:3000").
    return window.location.origin;

  // If the code reaches this point, we know we are on the server (because `window` was undefined).
  // Now, we check for a Vercel-specific environment variable.
  // `process.env.VERCEL_URL`: This is an environment variable that is automatically provided
  // by the Vercel hosting platform during a deployment build or when running server-side functions.
  if (process.env.VERCEL_URL) 
    
    // If this variable exists, it contains the unique deployment URL for our app. We use a
    // template literal to construct the full, secure URL (e.g., "https://my-t3-app.vercel.app").
    return `https://${process.env.VERCEL_URL}`;

  // If the code reaches this final return, it means we are on the server, but not in a Vercel
  // environment. The only remaining possibility is that we are running on a local development server.
  // We construct the default localhost URL.
  //
  // `process.env.PORT ?? 3000`: This uses the "nullish coalescing operator" (`??`) to safely
  // determine the port. It first checks if a `PORT` environment variable is set. If it is, it
  // uses that value. If `PORT` is not defined, it falls back to the standard default of `3000`.
  return `http://localhost:${process.env.PORT ?? 3000}`;
}
