// FINISH MY COMMENTS!!!!!!!!

/* This file, `src/trpc/react.tsx`, is automatically generated by `create-t3-app`.
 * It serves as the central configuration and setup hub for the client-side tRPC and
 * React Query integration. This file has NOT been modified from its default state.
 *
 * Its main responsibilities are:
 * 1. To create the main, type-safe `api` object. This is the primary "client" that is
 *    imported into components to make API calls (e.g., `api.task.getAll.useQuery()`).
 * 2. To define a "singleton" pattern for the `QueryClient`. This ensures that in the browser,
 *    there is only ever one single instance of the React Query cache, which is essential
 *    for a consistent application state.
 * 3. To create the `<TRPCReactProvider>` component. This is the main Context Provider that
 *    wraps the entire application in `layout.tsx`. It's responsible for initializing the
 *    tRPC client with the correct links (like HTTP batching and logging) and making both
 *    the tRPC client and the QueryClient available to the rest of the app.
 * 4. To export useful TypeScript "inference helpers" (`RouterInputs`, `RouterOutputs`) that
 *    allow you to easily get the TypeScript types for your API's inputs and outputs.
 */

// This directive is essential. It marks this file as a "Client Component" module.
// This means any component exported from this file (specifically `TRPCReactProvider`)
// can be used in other Client Components and can use client-side features like hooks (`useState`).
"use client";

// This line imports key components and types from `@tanstack/react-query`.
// `QueryClientProvider`: This is the main Context Provider from the React Query library.
// When it wraps your application, it makes the central `QueryClient` instance (the data cache)
// available to all components that use React Query hooks (which tRPC's hooks do).
//
// What does it mean to "wrap your application" with a Provider?
// In React, a Provider is a special component that you place at a high level in your component tree,
// typically in a root file like `layout.tsx`. You "wrap" your application by making all of your
// other pages and components its `children`.
//
// Like this in `layout.tsx`:
// <QueryClientProvider client={myQueryClient}>
//   {/* All of your other components go here */}
// </QueryClientProvider>
//
// By doing this, the `QueryClientProvider` makes a single, central `QueryClient` instance (the data cache)
// available to EVERY component nested inside it. Any component can then "hook into" this provider
// to access the cached data. This is what allows different components across your app to share the
// same data without having to pass it down manually as props.
//
// `type QueryClient`: This imports the TypeScript "type" definition for a `QueryClient` instance.
// We use this for type-safety when defining our singleton.
import { QueryClientProvider, type QueryClient } from "@tanstack/react-query";

// This line imports two "links" from the tRPC client library.
// What is a tRPC Link? A link is a piece of middleware.Middleware is code that "sits in the middle" of a
// request/response cycle to intercept and modify the operation. Think of it like a series
// of checkpoints on a road. Each checkpoint (link) can inspect the car (the tRPC request),
// log its details, or even turn it around before it reaches its final destination. You can
// chain multiple links together to build a custom processing pipeline.
// 
// `httpBatchStreamLink`: This is the most important link, the "final destination". It's the
// link that actually makes the HTTP request to your backend.
// - "Batching": A powerful performance optimization. If multiple queries are made in a very
//   short time, this link groups them into a single HTTP request, reducing network traffic.
// - "Streaming": For advanced use cases, tRPC can "stream" responses, meaning it can send
//   back data in chunks as it becomes available, rather than waiting for the entire response
//   to be ready. This can improve the perceived performance of your application.
//
// `loggerLink`: A helpful link for development. It acts as a "checkpoint" that intercepts
// every tRPC operation and logs its details (inputs, outputs, timing) to your browser's
// developer console, which is incredibly useful for debugging.
import { httpBatchStreamLink, loggerLink } from "@trpc/client";

// This imports the main factory function responsible for creating the entire client-side tRPC system for React.
// `createTRPCReact`: This function acts as the central bridge connecting three distinct worlds:
// 1. Your tRPC API's "shape" (defined on the backend).
// 2. The React Query library (for data fetching and caching).
// 3. The React framework itself (for building the user interface).
//
// You call this function once to create the main `api` object. This object becomes the primary
// interface your components will use to interact with the backend. It is populated with a custom,
// type-safe "hook system" that is perfectly tailored to your API's structure.
//
// What is the difference between a React Hook and a tRPC Hook:
//
//   - React Hook (e.g., `useState`, `useEffect`):
//     A "hook" is a special function in React (always starting with `use...`) that lets a component
//     "hook into" the core features of the **React library itself**. React is the underlying UI
//     framework responsible for rendering components, managing state, and tracking component lifecycles.
//     `useState`, for example, hooks into React's internal state management system.
//
//   - tRPC React Query Hook (e.g., `api.task.getAll.useQuery()`):
//     This is a custom hook that is built on top of the React Query library, but made available
//     through the tRPC `api` object. It is NOT part of the core React library. Its purpose is to
//     provide a simple way to "hook into" the external data fetching and caching logic provided by
//     the `QueryClient` (React Query's "brain"). When you call `api.task.getAll.useQuery()`, you are
//     telling React Query to manage the entire lifecycle of that specific data fetch, and tRPC ensures
//     this entire process is end-to-end type-safe.
//
// The `createTRPCReact` function is what generates this collection of custom tRPC React Query hooks.
import { createTRPCReact } from "@trpc/react-query";

// This line imports two special "type inference" utilities directly from the core tRPC server library.
// These are not runnable code; they are powerful, TypeScript-only tools that act like "type generators".
// Their purpose is to look at your backend API router (`AppRouter`) and automatically create TypeScript
// types that perfectly match the inputs and outputs of every single one of your API procedures.
// This is a cornerstone of tRPC's end-to-end type-safety.
//
// Imagine you have a tRPC procedure on your backend defined like this:
// `task.create: protectedProcedure.input(z.object({ title: z.string(), dueDate: z.date().optional() })).mutation(...)`
//
// Now, on your frontend, you want to create a variable that can hold the input for this procedure.
// Without these helpers, you would have to manually re-define the type in your frontend code:
// `type MyTaskInput = { title: string; dueDate?: Date; }`
// This is bad because if you ever change the backend validation (e.g., make `dueDate` required),
// you would have to remember to manually update the frontend type, or you would introduce a bug.
//
// The Solution (`inferRouterInputs` and `inferRouterOutputs`):
// These helpers automate the process. By using them later in this file to create the `RouterInputs`
// and `RouterOutputs` types, we can get the exact, up-to-date type for any procedure directly
// from the router itself, like this:
// `type MyTaskInput = RouterInputs['task']['create'];`
//
// Now, if you change the backend Zod schema, this `MyTaskInput` type on the frontend will
// automatically update, and TypeScript will immediately show you an error anywhere your
// frontend code is no longer correct. This eliminates an entire class of bugs and makes
// your codebase incredibly robust and easy to refactor.
//
// - `type inferRouterInputs`: The generic type used to generate the `RouterInputs` helper.
// - `type inferRouterOutputs`: The generic type used to generate the `RouterOutputs` helper.
import { type inferRouterInputs, type inferRouterOutputs } from "@trpc/server";

// Imports the `useState` hook from the React library itself.
// A "hook" is a special function (always starting with `use...`) that lets a function component
// "hook into" React's core features. `useState` is the most fundamental hook; it allows a
// component to have "state" â€” a variable whose value persists between renders and whose changes
// will automatically trigger a re-render of the component's UI.
import { useState } from "react";

// Imports the `SuperJSON` library, which is a critical part of the T3 stack's data flow.
// Standard JSON, which is used to send data over the internet,
// has limitations. It cannot properly handle complex JavaScript data types like `Date`, `Map`,
// `Set`, or `undefined`. These types are either converted into plain strings or lost entirely,
// breaking type-safety.
//
// `SuperJSON` is a library that extends JSON. It serializes these complex types into a special
// string format that includes their type information. On the other end, it can deserialize this
// string back into the original, correct JavaScript object. We use it in our tRPC "links" to
// ensure that a `Date` object from our server arrives as a real `Date` object in our client.
import SuperJSON from "superjson";

// This line imports the main `AppRouter` type from our backend's root API file.
// This is the single most important import for achieving tRPC's end-to-end type-safety.
// It's the "bridge" that allows our frontend code to be fully aware of our backend's API structure.
//
// 1. `import type { ... }`:
//    - The `import type` statement is a specific TypeScript feature. It's a signal to the compiler
//      that we are ONLY importing a type definition (`AppRouter`), not any runnable JavaScript code.
//    - This allows build tools to be smarter. Since types are completely
//      erased when TypeScript is compiled to JavaScript, the build tool knows it doesn't need
//      to include the `root.ts` file in the final client-side JavaScript bundle. This helps keep
//      the application size smaller and prevents server-side code from accidentally leaking
//      to the client.
//
// 2. `AppRouter`:
//    - This is NOT an object or a function. It is a TypeScript `type` alias.
//    - It is created in `~/server/api/root.ts` with the line:
//      `export type AppRouter = typeof appRouter;`
//    - The `typeof` operator inspects the actual `appRouter` object (which
//      contains all your procedures like `post.hello` and `task.create`) and generates a
//      massive, detailed TypeScript type that perfectly describes its entire structure. This
//      `AppRouter` type contains information about every router, every procedure, the exact
//      `input` type for each procedure (from Zod), and the exact `output` (return) type.
//
// 3. `"~/server/api/root"`:
//    - This is the path to the file where the `AppRouter` type is defined and exported. The `~/` is
//      a path alias that points to the `src` directory, configured in `tsconfig.json`.
//
// The entire T3 developer experience hinges on this line. Later in this file, we will create our
// main `api` client like this: `export const api = createTRPCReact<AppRouter>();`.
//
// - By passing `<AppRouter>` as a "generic type" to `createTRPCReact`, we are giving our client-side
//   setup a perfect, static "blueprint" of the entire backend API.
//
// - The `createTRPCReact` function uses this blueprint to auto-generate a fully typed `api` object.
//
// - This means when you type `api.task.create.mutate(` on the frontend, your code editor:
//   a) Knows that `.task` exists.
//   b) Knows that `.create` exists within `.task`.
//   c) Knows that the `.mutate` function for `.create` expects a specific input object (e.g., `{ name: string }`).
//   d) Knows that the `data` returned from a query like `api.task.getAll.useQuery()` will be an array of tasks.
//
// This is how a change on the backend (e.g., changing an input in a Zod schema) can immediately cause a
// TypeScript error on the frontend, catching bugs before they ever happen. This single `import type`
// is what makes the entire "end-to-end type-safety" promise a reality.
import { type AppRouter } from "~/server/api/root";

// This line imports the `createQueryClient` "factory function" from the neighboring `query-client.ts` file.
// This function acts as the single, authoritative blueprint for creating a `QueryClient` instance.
// It is used here to create the client-side instance, and it's also used in `~/trpc/server.ts`
// to create the server-side instance. Using this single factory guarantees that both environments
// share the exact same configuration, which is essential for the hydration process to work correctly.
import { createQueryClient } from "./query-client";

// This line declares a module-level variable that will store our single, persistent QueryClient instance for the browser.
//
// - `let`: We use `let` instead of `const` because the value of this variable will be reassigned exactly once,
//   from its initial state of `undefined` to the actual `QueryClient` instance the first time it's needed.
// - `clientQueryClientSingleton`: The descriptive name makes its purpose clear. A "singleton" is a design
//   pattern that restricts an object to only one single instance across an entire application.
// - `: QueryClient | undefined`: This is a TypeScript "union type". It declares that this variable can
//   hold one of two possible types: either a full `QueryClient` object OR the value `undefined`.
// - `= undefined`: We explicitly initialize the variable to `undefined`. This represents the initial
//   state where the client-side `QueryClient` has not yet been created.
let clientQueryClientSingleton: QueryClient | undefined = undefined;

// This defines a "getter" function. Instead of accessing the singleton variable directly, the rest of our
// code will call this function. This function's job is to encapsulate the logic for either returning
// the existing instance or creating a new one if it doesn't exist yet, depending on the environment.
const getQueryClient = () => {

  // This `if` statement is the crucial environment check. Its purpose is to determine if the code is
  // currently running on the server (during server-side rendering) or in the client's browser.
  //
  // - `window`: This is the global object that exists ONLY in a web browser environment. It contains all
  //   the browser APIs like `document`, `location`, etc.
  // - `typeof window`: This is a safe way to check for its existence.
  //   - **In a browser:** `window` is an object, so `typeof window` will return the string `"object"`.
  //   - **On the server (Node.js):** The `window` object does not exist. Trying to access a non-existent
  //     variable would normally throw an error, but the `typeof` operator is special. It will safely
  //     return the string `"undefined"` instead of crashing.
  if (typeof window === "undefined") {

    // The code inside this `if` block is executed ONLY when the function is running on the server.
    
    // This comment from the T3 boilerplate summarizes the server-side strategy:
    // "Server: always make a new query client"
    
    // We call our `createQueryClient` factory function and immediately return the new instance.
    // Why create a NEW client every time on the server:
    // This is a critical architectural decision for data safety and isolation. Every incoming
    // request to your server (from different users, or even different browser tabs from the same user)
    // is a separate, isolated event. If we were to reuse the same QueryClient instance across
    // different user requests on the server, there would be a risk of one user's cached data
    // accidentally "leaking" and being shown to another user. By creating a fresh, new
    // `QueryClient` for every single request, we guarantee that each user's data fetching
    // process is completely isolated and secure.
    return createQueryClient();
  }

  // The code below this point is executed ONLY when the function is running in the user's browser.
  
  // This comment from the T3 boilerplate summarizes the client-side strategy:
  // "Browser: use singleton pattern to keep the same query client"
  
  // This single line is the core of the client-side singleton pattern. It ensures that the
  // `createQueryClient()` factory is called only ONCE for the entire lifecycle of the application in the browser.
  //
  // The line `a ??= b` is the equivalent of writing this:
  // `if (a === null || a === undefined) { a = b; }`
  //
  // 1. The first time this runs the `clientQueryClientSingleton` variable is `undefined`. The `??=`
  //    operator checks this, finds that it is "nullish", and executes the code on the right side.
  //    It calls `createQueryClient()`, which creates a new `QueryClient` instance. This new instance
  //    is then **assigned** back to the `clientQueryClientSingleton` variable.
  //
  // 2. On any subsequent call to `getQueryClient` (e.g., from a different
  //    component or a re-render), the `clientQueryClientSingleton` variable now holds the `QueryClient`
  //    instance created in the first step. The `??=` operator checks it, finds that it is NOT nullish,
  //    and does nothing. The code on the right side is NOT executed.
  //
  // This guarantees we have one single, persistent "data brain" for the user's entire session in their browser tab.
  clientQueryClientSingleton ??= createQueryClient();

  // This line returns the `clientQueryClientSingleton` variable.
  // Thanks to the logic above, we can be 100% certain that by the time this line is reached,
  // the variable holds the one and only instance of our `QueryClient` for the browser.
  return clientQueryClientSingleton;
};

// This line creates and exports the main, client-side tRPC `api` object.
// This `api` object is the single most important export from this file. It is the "entry point"
// that all of your client-side components will import to interact with your backend API.
//
// 1. `export const api = ...`: We are creating a constant named `api` and immediately exporting it so
//    it can be used in other files (e.g., `import { api } from "~/trpc/react"`).
//
// 2. `createTRPCReact<AppRouter>()`: This is the call to the factory function we imported.
//
//    - `createTRPCReact`: This function is the builds our tRPC integration for React.
//      It takes a generic type as its input and returns a fully configured object that contains all
//      the necessary hooks and providers. We are assigning this returned object to our `api` constant.
//
//    - `<AppRouter>`: This is a "Generic Type Argument". This is the absolute core of tRPC's
//      end-to-end type-safety. We are passing the `AppRouter` type (which we imported from our
//      backend) into the factory. This `AppRouter` is a perfect TypeScript "blueprint" of our
//      entire API's structure.
//
// `createTRPCReact` reads the `AppRouter` type and dynamically generates a corresponding `api` object that is
// perfectly typed. For every procedure in your backend (like `task.create`), this `api` object
// will have a corresponding, fully-typed hook (`api.task.create.useMutation`). This is what
// provides the magical autocompletion and type-checking in your components.
export const api = createTRPCReact<AppRouter>();

// This line creates and exports a TypeScript "helper type" named `RouterInputs`.
// This is not runnable code; it's a powerful tool for your development experience that
// allows you to easily get the exact TypeScript types for the inputs of any of
// your API procedures without defining them manually.
//
// 1. `export type RouterInputs = ...`: This syntax creates and exports a "Type Alias".
//    A type alias is a feature in TypeScript that allows you to create a new, custom name for
//    another type. It doesn't create a new type, but rather a "nickname" or "shortcut" for
//    an existing one. This is incredibly useful for making complex types (like the ones
//    generated by tRPC) easier to read and reuse. Here, we are creating a new name, `RouterInputs`,
//    for the complex type that is generated on the right-hand side of the `=`.
//
// 2. `inferRouterInputs<AppRouter>`: This is the tRPC "inference helper" that generates the complex type.
//    - `inferRouterInputs`: This is a powerful "generic type" provided by tRPC. Its job is to
//      programmatically inspect an API router's shape.
//    - `<AppRouter>`: We pass it our API's complete "blueprint" (`AppRouter`).
//
// The `inferRouterInputs<AppRouter>` utility analyzes your entire backend API and generates a
// single, massive, nested object type. This type maps out the exact input shape for every single
// procedure. The `RouterInputs` alias now holds this generated type.
//
// Imagine your backend has a procedure `task.create` that takes an input like `{ title: string }`.
// In your frontend code, you can now use the `RouterInputs` alias to access the type for that specific input:
// `type MyCreateTaskInput = RouterInputs['task']['create'];`
//
// TypeScript will now understand that `MyCreateTaskInput` is exactly `{ title: string }`. If you ever
// change the backend input schema, this `MyCreateTaskInput` type will **automatically update**. This
// is the core of tRPC's end-to-end type safety, as it eliminates the need to manually keep
// frontend and backend types in sync.
/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

// This line creates and exports another TypeScript "type alias" named `RouterOutputs`.
//
// It works in the exact same way as `RouterInputs` above, but it's for the return values (outputs)
// of your API procedures. It uses the `inferRouterOutputs` helper to inspect your `AppRouter`
// and generate a type that maps out the exact shape of the data returned by every procedure.
//
// Example Usage:
// `type MyTask = RouterOutputs['task']['getById'];`
// This would give you the exact type of the task object returned from that specific API endpoint.
/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;

// This defines and exports a React "Function Component" that will act as the main Context Provider
// for our entire tRPC and React Query setup. This is the component that will be used in `layout.tsx`
// to wrap the entire application, making all data-fetching capabilities available globally.
//
// `(props: { children: React.ReactNode })`: The component is defined to accept a `props` object.
// - `props`: The object containing all properties passed to the component.
// - `{ children: React.ReactNode }`: This is the TypeScript type for the props object. It specifies
//   that this component must receive a `children` prop, which can be any valid React content. This is
//   what allows it to act as a wrapper around other components.
export function TRPCReactProvider(props: { children: React.ReactNode }) {

  // This line calls the `getQueryClient` function that we defined earlier in this file.
  // This function's logic ensures that we get the single, persistent, singleton instance of the
  // `QueryClient` (the data cache "brain") when running in the browser.
  const queryClient = getQueryClient();


  const [trpcClient] = useState(() =>
    api.createClient({
      links: [
        loggerLink({
          enabled: (op) =>
            process.env.NODE_ENV === "development" ||
            (op.direction === "down" && op.result instanceof Error),
        }),
        httpBatchStreamLink({
          transformer: SuperJSON,
          url: getBaseUrl() + "/api/trpc",
          headers: () => {
            const headers = new Headers();
            headers.set("x-trpc-source", "nextjs-react");
            return headers;
          },
        }),
      ],
    }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <api.Provider client={trpcClient} queryClient={queryClient}>
        {props.children}
      </api.Provider>
    </QueryClientProvider>
  );
}

function getBaseUrl() {
  if (typeof window !== "undefined") return window.location.origin;
  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
  return `http://localhost:${process.env.PORT ?? 3000}`;
}
