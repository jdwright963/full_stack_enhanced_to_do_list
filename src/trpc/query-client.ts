/* This file is automatically generated by `create-t3-app`. Its purpose is to create and
 * configure the `QueryClient`, which is the "brain" of the entire T3 data-fetching layer.
 * To understand this file, it's essential to understand the key players:
 *
 * 1. React Query (`@tanstack/react-query`):
 *    - What it is: A powerful, standalone library for data fetching and caching. It is NOT part of React or tRPC.
 *    - Its Job: To be the central "data brain". It handles all the complex logic of caching data,
 *      tracking loading/error states, and automatically re-fetching data to keep it fresh.
 *
 * 2. The `QueryClient`:
 *    - What it is: The main object from the React Query library. An instance of `QueryClient` IS the cache.
 *    - The "Two Brains" Architecture: In the T3 stack, a temporary `QueryClient` is created on the server for
 *      each request, and a long-lived `QueryClient` exists on the client (in the browser). This file is the
 *      single blueprint used to create BOTH, ensuring their settings are identical.
 *
 * 3. tRPC (`@trpc/...`):
 *    - What it is: The type-safe API framework.
 *    - Its Job: To provide a seamless, type-safe way to call backend procedures. In the T3 stack, tRPC is
 *      configured to use React Query as its data management "engine". When you call a tRPC hook like
 *      `api.task.getAll.useQuery()`, it's actually telling the `QueryClient` to manage the fetching and caching.
 *
 * 4. Hydration (The Bridge between Server and Client):
 *    - Dehydration (Server): The process of taking data from the server's `QueryClient`, serializing it
 *      into a string, and sending it to the browser with the initial HTML.
 *    - Hydration (Client): The process of taking that string and using it to pre-populate the client's `QueryClient`,
 *      so the client doesn't need to immediately re-fetch data it already has.
 *
 * This file configures the `QueryClient` with specific settings (like `staleTime` and `superjson`
 * serialization) that are essential for making this server-to-client hydration process work seamlessly and efficiently.
 */

// This line imports two key utilities from `@tanstack/react-query`, the powerful data-fetching
// and caching library that powers the tRPC client.
import {

  // `defaultShouldDehydrateQuery`: This is a helper function provided by the library.
  // "Dehydration" is the process of taking the data from the server-side query cache (`QueryClient`) and
  // serializing it into a string so it can be sent to the client as part of the initial HTML.
  // This function contains the library's default logic for deciding which queries
  // should be dehydrated. We import it here so we can call it and extend its logic.
  defaultShouldDehydrateQuery,

  // `QueryClient`: This is the main class from the library. An instance of `QueryClient`
  // is the central cache and manager for all of your application's server state. It stores
  // fetched data, tracks loading and error states, and handles re-fetching.
  QueryClient,
} from "@tanstack/react-query";

// Imports the `SuperJSON` library.
// Standard JSON can't handle complex JavaScript data types
// like `Date`, `Map`, `Set`, or `undefined`. They either cause errors or are converted into
// plain strings, losing their original type. `SuperJSON` is a library that extends the
// standard JSON functionality, allowing these complex types to be correctly serialized and
// deserialized, preserving their type information. This is
// essential for tRPC's end-to-end type safety.
import SuperJSON from "superjson";

// This line defines and exports an arrow function named `createQueryClient`.
// This is a "factory function" - its only job is to create and return a new, fully configured
// instance of an object, in this case, the `QueryClient`.
export const createQueryClient = () =>

  // This creates a new instance of the `QueryClient` class.
  // We pass a single, large configuration object to its constructor to define its default behavior.
  new QueryClient({

    // `defaultOptions`: This property allows us to set default options that will apply to
    // all queries, mutations, etc., throughout the entire application, unless they are
    // overridden in a specific `useQuery` or `useMutation` call.
    defaultOptions: {

      // We are specifically setting default options for all query-type operations
      // (i.e., any data-fetching initiated by `useQuery`, `useSuspenseQuery`, etc.).
      queries: {
        
        // This comment, provided by the T3 boilerplate, hints at the purpose of the setting below:
        // "With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client."

        // `staleTime`: This is one of the most important configuration options in React Query.
        // It defines the duration in milliseconds that cached data is considered "fresh".
        //
        // - Fresh: As long as data is fresh, React Query will always use the data from the cache
        //   without making a new network request.
        // - Stale: Once the `staleTime` has passed, the data is considered "stale". The next time
        //   the data is needed, React Query will show the stale data instantly (for a fast UI),
        //   but it will also trigger a new network request in the background to get the latest data.
        //
        // The default `staleTime` in React Query is `0`, meaning data becomes stale immediately.
        //
        // Why we set it to 30 seconds (`30 * 1000`):
        // This is a critical optimization for the T3 stack's hydration process.
        // 1. On the server, we fetch data and send it to the client.
        // 2. The client "hydrates" this server-fetched data into its `QueryClient` cache.
        // 3. If `staleTime` were `0`, the client would immediately consider this data stale and
        //    trigger an unnecessary API call to re-fetch the exact same data it just received.
        //
        // By setting `staleTime` to 30 seconds, we are telling the client: "Trust the data you
        // just received from the server. It is fresh for the next 30 seconds. Do not refetch it
        // immediately." This prevents redundant API calls on initial page load.
        staleTime: 30 * 1000,
      },

      // `dehydrate`: This property contains options that control the "dehydration" process.
      // "Dehydration" is the process of taking the in-memory data from the server-side `QueryClient` cache
      // and serializing it into a string format (in this case, a SuperJSON string). This serialized
      // string is then embedded in the initial HTML sent to the browser. It's like freeze-drying
      // the server's cache so it can be shipped to the client.
      dehydrate: {

        // `serializeData`: This option tells React Query how to serialize the data for each query.
        // By default, it would use standard `JSON.stringify`, which would break complex types like Dates.
        // `SuperJSON.serialize`: We are overriding the default and telling it to use the `serialize`
        // method from the SuperJSON library. This ensures that complex data types are correctly
        // converted into a special string format that preserves their type information.
        serializeData: SuperJSON.serialize,

        // `shouldDehydrateQuery`: This option is a function that acts as a "filter". It is called for
        // every single query in the server's cache, and it must return `true` or `false`. Only queries
        // for which this function returns `true` will be included in the dehydrated (serialized) data.
        // The function receives a `query` object, which contains information about a specific query in the cache.
        // The logic here extends the default behavior.
        shouldDehydrateQuery: (query) =>

          // Part 1: `defaultShouldDehydrateQuery(query)`
          //   - We first call the original `defaultShouldDehydrateQuery` function that we imported.
          //     This function contains React Query's built-in logic for which queries to include
          //     (for example, it will return `true` for queries that have successfully finished fetching data).
          //
          // Part 2: `||` (Logical OR)
          //   - If the default check returns `true`, the entire expression becomes `true`, and the query will be included.
          //
          // Part 3: `query.state.status === "pending"`
          //   - This is the T3 stack's custom addition. It adds another condition: "Also include queries
          //     whose status is currently `pending`."
          //
          // Let's trace the data flow to understand the problem this solves:
          // 1. On the server, a Server Component calls a tRPC query (e.g., `api.post.getAll()`).
          // 2. This query is immediately added to the server's `QueryClient` cache with a status of `pending` because
          //    the data fetching has just started and has not finished yet.
          // 3. The server then needs to "dehydrate" its cache to send it to the client.
          //
          // Without `|| query.state.status === "pending"`:
          // The default React Query logic would see the `pending` query and say, "This query isn't finished and
          // has no data, so I will NOT include it in the dehydrated state." The client would receive an empty
          // cache for this query. The client-side tRPC hook would see the empty cache and say, "I guess I
          // need to start fetching this data from scratch," triggering a completely redundant API call.
          //
          // With `|| query.state.status === "pending"`:
          // Our custom logic tells the server, "Yes, I know this query is still pending, but I want you to
          // include it in the dehydrated state anyway."
          // The client receives the dehydrated state and sees a query marked as `pending`. The client-side
          // tRPC hook then says, "Aha! The server has already started fetching this data for me. I will not
          // start a new request. I will simply wait for the server's original request to complete."
          //
          // This ensures a seamless and efficient data flow. The data fetching is initiated on the server,
          // and the client intelligently "adopts" or "waits for" that existing data fetch instead of
          // wastefully starting its own.
          defaultShouldDehydrateQuery(query) ||
          query.state.status === "pending",
      },

      // `hydrate`: This property contains options that control the "hydration" process.
      // "Hydration" is the process of taking the serialized data string (which was "dehydrated"
      // on the server and sent with the initial HTML) and re-populating the client-side
      // `QueryClient` cache with it. It's like adding water to the "freeze-dried" server cache
      // to bring it back to a living, usable state in the browser.
      hydrate: {

        // `deserializeData`: This option tells React Query how to parse the serialized data
        // for each query it finds in the hydration payload.
        // By default, it would use standard `JSON.parse`, which would not correctly handle the
        // special format used by SuperJSON for complex types like Dates.
        //
        // `SuperJSON.deserialize`: We are overriding the default and telling React Query to use the
        // `deserialize` method from the SuperJSON library. This function knows how to read the
        // special SuperJSON string format and correctly reconstruct the original JavaScript objects,
        // preserving all the complex types.
        //
        // This is the crucial final step that completes the end-to-end type-safe data flow,
        // ensuring that a `Date` object on the server arrives as a `Date` object on the client.
        deserializeData: SuperJSON.deserialize,
      },
    },
  });
