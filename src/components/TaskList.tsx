// This file defines the `TaskList` React component. This is a "Client Component",
// as indicated by the `"use client";` directive. Its primary responsibility is to
// fetch and display the list of all tasks for the user.

// This directive is essential. It marks this file and all components within it as "Client Components".
// This means their JavaScript will be sent to and executed in the user's browser. This is a requirement
// because this component needs to use client-side hooks (`useState`, tRPC hooks) and handle user
// interactions (`onClick` events).
'use client';

// Imports the main `api` object from our central tRPC client-side setup file (`~/trpc/react.ts`).
// This `api` object is the "entry point" that contains all the fully type-safe React Query hooks
// that correspond to our backend's API procedures.
import { api } from "~/trpc/react";

// This line defines and exports a new React function component named `TaskList`.
// `export`: This makes the component available to be imported and used in other files (like a page component).
// `function TaskList()`: This is a standard JavaScript function declaration. In React, components are just
// functions that return JSX (the UI structure).
export function TaskList() {

  // This line calls the `api.useContext()` hook to get access to the tRPC utility client.
  //
  // It's crucial to understand that this is NOT the server-side context (`ctx`) that contains
  // the database (`db`) or user session. Instead, this hook returns a special `utils` object
  // that acts as a programmatic API for directly interacting with the client-side React Query cache.
  //
  // The primary use for this `utils` object is to manually control the cache after a mutation.
  // We will use its `.invalidate()` method to tell React Query that our list of tasks is
  // out-of-date, which will automatically trigger a re-fetch to keep the UI in sync.
  const utils = api.useContext();

  // This is the core data-fetching hook for this component. It calls our `task.getAll` tRPC procedure.
  // `api.task.getAll.useQuery()`: This hook, generated by tRPC, tells React Query to fetch the data
  // from our backend. React Query then manages the entire lifecycle of this request: caching,
  // loading states, error handling, and re-fetching in the background.
  //
  // `const { ... } = ...`: The `useQuery` hook returns a large object with the request's status. We are using
  // "object destructuring" to pull out only the specific properties we need.
  //
  // - `data: tasks = []`: This is a three-part pattern:
  //   1. `data`: The hook returns the fetched data from the server in a property named `data`.
  //   2. `: tasks`: We use "destructuring with rename" to assign the value of `data` to a more
  //      descriptive local variable named `tasks`.
  //   3. `= []`: We provide a "default value". While the data is loading, `data` will be `undefined`.
  //      This default value ensures that `tasks` is always an array, preventing our code from crashing
  //      when we try to call `.map()` on it in the JSX below.
  //
  // - `isLoading`: This is a boolean value provided by React Query. It is `true` only when the
  //   query is making its very first network request for data, and `false` at all other times.
  //   We use this to conditionally render a "Loading..." message.
  const { data: tasks = [], isLoading } = api.task.getAll.useQuery();

  // This line sets up the "mutation" for toggling a task's completion status.
  // A "mutation" is any operation that changes data on the server.
  //
  // `api.task.toggle.useMutation()`: Unlike `useQuery`, this hook does NOT run automatically. Instead,
  // it returns an object (which we are storing in the `toggleTask` constant) that contains a
  // `.mutate()` function. We will call this `toggleTask.mutate()` function later (e.g., in an `onClick`
  // handler) to actually trigger the API call.
  //
  // The hook takes a configuration object as its argument, allowing us to define "callbacks"
  // that run at different points in the mutation's lifecycle.
  const toggleTask = api.task.toggle.useMutation({

    // `onSuccess`: This is a callback function that React Query will automatically execute ONLY IF
    // the mutation was successful on the server. This is the perfect place to run logic that
    // needs to happen after a data change, like updating the UI.
    onSuccess: () => 
      
      // This is the key to making our UI reactive. We are using the `utils` object we created earlier.
      // `utils.task.getAll.invalidate()`: This command does NOT manually re-fetch the data. Instead, it
      // tells React Query: "The cached data for the `task.getAll` query is now out-of-date and invalid."
      //
      // Because our component is currently using that `task.getAll` query (via `useQuery`), React Query
      // sees that its data has been invalidated and AUTOMATICALLY triggers a re-fetch in the background
      // to get the new, up-to-date list of tasks. This is what makes the UI update after a mutation.
      utils.task.getAll.invalidate(),
  });

// This line sets up the "mutation" for deleting a task. The pattern is identical
  // to the `toggleTask` mutation above.
  //
  // `api.task.delete.useMutation()`: This hook from our tRPC client does not run immediately.
  // It returns a `deleteTask` object that contains a `.mutate()` function. We will call this
  // function in an `onClick` handler below to trigger the actual API call to delete a task.
  const deleteTask = api.task.delete.useMutation({

    // `onSuccess`: This callback function is executed by React Query only if the `delete`
    // mutation on the server completes successfully.
    onSuccess: () => 
      
      // `utils.task.getAll.invalidate()`: Just like with the toggle mutation, we immediately
      // invalidate the `task.getAll` query. This tells React Query that our cached list
      // of tasks is now stale, which automatically triggers a background re-fetch to get
      // the updated list (without the deleted task), ensuring the UI stays in sync.
      utils.task.getAll.invalidate(),
  });

  // This is a conditional rendering "guard clause". It's a standard and essential pattern
  // for handling loading states when fetching data.
  //
  // `if (isLoading)`: The `isLoading` boolean is provided by our `api.task.getAll.useQuery()`
  // hook. It will be `true` only during the initial fetch for the task list.
  if (isLoading) {

    // If the data is still loading, we immediately `return` this simple JSX. This stops
    // the component from rendering any further. The user will see a "Loading tasks..."
    // message on the screen instead of an empty or broken UI. Once the data fetching
    // is complete, `isLoading` will become `false`, and the component will automatically
    // re-render, proceeding past this `if` block to the main JSX below.
    return <p>Loading tasks...</p>;
  }

  // This is the component's main `return` statement. It defines the JSX that will be rendered.
  return (

    // This renders the main `<ul>` (unordered list) container for all the task items.
    // `className="space-y-2"`: This is a powerful Tailwind utility that adds a consistent
    // vertical margin between all direct children of this element (i.e., between each task
    // list item), creating a clean, evenly spaced list.
    <ul className="space-y-2">

      {// This is the core of rendering the dynamic list. We use curly braces `{...}` to embed a
      // JavaScript expression directly into our JSX.
      // `tasks.map(...)`: We call the standard JavaScript `.map()` method on our `tasks` array.
      // This method iterates over every `task` object in the array and executes the provided
      // arrow function for each one, returning a new array of `<li>` elements. React then
      // efficiently renders this array of elements into the DOM.
      }
      {tasks.map((task) => (

        // This renders a single list item (`<li>`) for each task in the array.
        //
        // `key={task.id}`: This is a special and required prop in React when rendering lists. It gives
        // each element a stable, unique identity. React uses this key to efficiently update, add, or
        // remove items from the list without having to re-render the entire thing. The task's
        // unique database ID is the perfect value for this.
        //
        // `className`: Styles the list item using several Tailwind utilities.
        // - `flex`: This enables a "Flexbox" layout for the items inside the `<li>`.
        //   - A Flexbox is a modern CSS layout model for easily arranging items in a single row (default) or column.
        // - `justify-between`: A Flexbox property that pushes the child elements to opposite ends of the container
        //   (the task title to the far left, the delete button to the far right).
        // - `items-center`: A Flexbox property that vertically aligns the items in the middle of the `<li>`.
        // - The remaining classes add a border, padding, and rounded corners for styling.
        <li key={task.id} className="flex justify-between items-center border p-2 rounded border-gray-700">
          
          {// This `<span>` element wraps the task title text, making it an interactive, clickable area.
          }
          <span

            // `onClick`: This is the React event handler for a mouse click. We are providing it with a
            // function that will be executed *only when* the user clicks on this `<span>`.
            //
            // --- The "Right Way" vs. The "Wrong Way" ---
            //
            // 1. The Right Way (What we are doing):
            //    `onClick={() => toggleTask.mutate({ id: task.id })}`
            //    - We are giving `onClick` an **arrow function definition**: `() => { ... }`.
            //    - This is like handing React a "recipe" or a "set of instructions". React holds onto
            //      this recipe and will only follow the instructions (i.e., call `toggleTask.mutate`)
            //      at the exact moment the user clicks.
            //
            // 2. The Wrong Way (A common mistake):
            //    `onClick={toggleTask.mutate({ id: task.id })}`
            //    - If we wrote it like this (without the `() =>`), the `toggleTask.mutate` function would be
            //      called immediately as soon as the component renders.
            //    - This would trigger a mutation for every single task in the list the moment the page loads,
            //      which is a major bug.
            //
            // The `() => ...` wrapper is the essential pattern for passing arguments to an event
            // handler in React. It defers the execution of the function until the event actually happens.
            //
            // Inside the arrow function, we call `toggleTask.mutate()`, which executes the mutation we set up earlier.
            // We pass it an object `{ id: task.id }`, providing the unique ID of the specific task that
            // was clicked, which is required by our backend's `task.toggle` procedure.
            onClick={() => toggleTask.mutate({ id: task.id })}

            // This `className` prop is what dynamically styles the task text based on its completion status.
            //
            // 1. `` `...` ``: We use "template literals" (backticks) to build the final string of class names.
            //    This is necessary because we need to embed a JavaScript expression inside the string.
            //
            // 2. `cursor-pointer`: This is a standard Tailwind utility that applies the CSS rule
            //    `cursor: pointer;`. This changes the mouse cursor to a "hand" icon when the user
            //    hovers over the task title, visually indicating that it is a clickable element.
            //
            // 3. `${ ... }`: This is an "interpolation" placeholder within the template literal. The JavaScript
            //    expression inside the curly braces will be evaluated, and its result will be inserted
            //    into the final string.
            //
            // 4. `task.completed ? "line-through text-gray-500" : ""`: This is a "ternary operator",
            //    a compact if-else statement.
            //    - The Condition (`task.completed`): It checks the boolean `completed` property of the current `task` object.
            //    - If `true`: It returns the string `"line-through text-gray-500"`. These Tailwind classes
            //      will be added to the `className`, striking through the text and making it gray to
            //      visually show that the task is done.
            //    - If `false`: It returns an empty string `""`. No extra classes are added, and the
            //      task title is rendered in its default, un-styled state.
            className={`cursor-pointer ${task.completed ? "line-through text-gray-500" : ""}`}
          >

            {// This is the actual content that gets rendered inside the `<span>`. We use curly braces
            // to embed the `task.title` variable, which is the string containing the task's name
            // that we got from the database.
            }
            {task.title}
          </span>

          {// This renders a standard HTML `<button>` element for the delete action. Using a semantic
          // `<button>` is important for accessibility, as screen readers will correctly announce it as a "button".
          }
          <button

            // `onClick`: This is the React event handler for a mouse click. Just like with the toggle action,
            // we use an inline arrow function `() => ...` to defer the execution of `deleteTask.mutate`
            // until the exact moment the user clicks the delete button.
            //
            // `deleteTask.mutate({ id: task.id })`: This calls the `.mutate()` function on the `deleteTask`
            // object we created with `useMutation`. It triggers the `task.delete` procedure on our
            // backend, passing the specific `id` of the task to be deleted.
            onClick={() => deleteTask.mutate({ id: task.id })}

            // The `className` prop applies Tailwind CSS utility classes to style the button.
            // - `text-red-500`: Sets the text color to a shade of red, a common UI convention to indicate
            //   a destructive or dangerous action like deleting something.
            // - `hover:underline`: This is a "state variant". It applies an underline to the text ONLY
            //   when the user's mouse is hovering over the button, providing clear interactive feedback.
            className="text-red-500 hover:underline"
          >

            {// This is the visible text content that is rendered inside the button.
            }
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
}