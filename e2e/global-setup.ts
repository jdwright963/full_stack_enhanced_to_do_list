// This file defines the "global setup" for the entire Playwright test suite. It is a
// special script that Playwright is configured to run exactly ONCE, before any test
// files are executed.
//
// Its primary and sole purpose is to prepare the test database to be in a clean,
// known, and predictable state before the tests begin. This ensures that every single
// test run is completely isolated and repeatable, which is the cornerstone of reliable
// automated testing.
//
// The script performs two main actions:
//
// 1. CLEANING THE DATABASE:
//    It connects to the test database and completely wipes all data from the tables
//    that are relevant to the tests (`Task`, `User`, `Account`, `Session`). This
//    prevents data from one test run from affecting the outcome of the next.
//
// 2. SEEDING THE DATABASE:
//    After the database is clean, it "seeds" it with the necessary prerequisite data.
//    Specifically, it creates a single, static, pre-verified user. This user account
//    is then used by tests like `task-flow.spec.ts` to log in and test features that
//    require an authenticated session.

// This line imports the main `PrismaClient` class from the `@prisma/client` package.
// The `@prisma/client` package is automatically generated by the `prisma generate` command.
// It reads the `schema.prisma` file and creates a fully type-safe database client
// that is perfectly tailored to this specific database schema. The `PrismaClient` class
// is the main entry point for all database interactions.
import { PrismaClient } from '@prisma/client';

// This line creates a new instance of the Prisma Client and assigns it to a constant
// named `prisma`. This `prisma` object is what we will use to send queries and mutations
// to our test database. It contains properties that map directly to our database models,
// like `prisma.user` and `prisma.task`, along with all the necessary methods like `.create()`,
// `.findMany()`, `.deleteMany()`, etc.
const prisma = new PrismaClient();

// This defines the main asynchronous function that Playwright will execute as the global setup.
// `export default globalSetup;` at the bottom of the file makes this function available to Playwright.
// The `async` keyword is essential because all of our database operations will be asynchronous
// and we need to use the `await` keyword to handle them.
async function globalSetup() {
  console.log("Starting global setup: Cleaning and seeding test database...");

  // This line reads the `DATABASE_URL` environment variable.
  // `process.env`: This is a global object in Node.js that contains all the environment
  // variables for the current process. When Playwright runs this script, it will have loaded
  // the variables from your `.env.test` file (for local runs) or from GitHub Secrets (for CI runs),
  // making them available on `process.env`.
  const databaseUrl = process.env.DATABASE_URL;

  // This is a critical "guard clause" or "sanity check". Its purpose is to ensure that the
  // `DATABASE_URL` was actually found in the environment before we try to do anything else.
  // `if (!databaseUrl)`: This condition will be true if the `databaseUrl` variable is `undefined`,
  // `null`, or an empty string.
  if (!databaseUrl) {

    // If the `DATABASE_URL` is missing, we immediately stop the entire test run by throwing an Error.
    // This is a "fail-fast" approach. It's much better to have a clear, immediate error here
    // than to let the script continue and fail later with a more confusing "cannot connect to database"
    // error.
    throw new Error("DATABASE_URL is not set in the environment for global-setup.");
  }
  
  // The `try...catch...finally` block is a robust pattern for handling operations that might
  // fail, such as connecting to or querying a database. The main logic we expect to work
  // goes inside this `try` block. If any error occurs, execution will immediately jump to the
  // `catch` block.
  try {
    
    // This line explicitly opens a connection to the database.
    // While Prisma often manages connections automatically ("lazily") when the first query is made,
    // calling `prisma.$connect()` is a good practice in a setup script. It allows you
    // to confirm that a valid connection can be established right at the beginning, before
    // you attempt any other database operations. If the connection fails, it will throw an
    // error here that can be caught.
    await prisma.$connect();

    // This is the beginning of the database cleanup. We are deleting all records from the `Task` table.
    // `prisma.task`: Accesses the part of the Prisma Client that corresponds to the `Task` model.
    // `.deleteMany({})`: This is a Prisma method that deletes multiple records. By passing an
    // empty object `{}` as the filter criteria, we are telling it to match and delete all
    // records in the table. We delete tasks first because they have a relationship to the `User` model,
    // and it's a best practice to delete "child" records before "parent" records.
    await prisma.task.deleteMany({});
    
    // Similarly, we delete all records from the `Account` table. The `Account` model is used
    // by NextAuth.js and also has a relationship to the `User` model.
    await prisma.account.deleteMany({});

    // We delete all records from the `Session` table. This table is also used by NextAuth.js
    // and is linked to the `User` model.
    await prisma.session.deleteMany({});
    
    // This is the final and most important cleanup step. Now that all the "child" records that
    // depend on the `User` model have been deleted, it is safe to delete all records from the `User` table.
    // If we had tried to delete the users first, the database might have thrown a "foreign key constraint"
    // error because other records still depended on them.
    await prisma.user.deleteMany({});

    // This is the "seeding" phase. Now that the database is clean, this command creates a single,
    // static, predictable user that our other tests can rely on for logging in.
    //
    // `await prisma.user.create(...)`: This is an asynchronous Prisma Client method that inserts
    // a new record into the `User` table in our database. It takes a single object argument
    // that specifies the data for the new user.
    await prisma.user.create({

      // The `data` property is a required key for a `create` operation. Its value is an object
      // where the keys are the names of the columns in your `User` table and the values are the
      // data you want to insert for this new user record.
      data: {

        // We are setting the `email` column to a hardcoded string. This is the
        // email that our `task-flow.spec.ts` test will use to log in.
        email: "jdwright963@gmail.com",
        
        // This is the most important field. We are setting the `password` column.
        // The value MUST be a pre-hashed password string. It is a major security vulnerability to
        // ever store plain-text passwords in a database. This specific hash was generated
        // manually using a script with the `bcryptjs` library to match the exact hashing
        // algorithm that our application's backend uses for real user registrations.
        // The password before hashing was: password123
        password: "$2b$10$P.9yUes8yeakXlonnuE/BOYESKYQQb8Bl8rdsYCA5h9LbOVEdjafG",

        // We are setting the `emailVerified` column to the current date and time. By seeding
        // this user as already verified, we simplify the login process for the other tests,
        // as they don't have to worry about the email verification step. `new Date()` creates
        // a new JavaScript `Date` object representing the current moment.
        emailVerified: new Date(),
      },
    });

  // The `catch` block will execute if any error was thrown at any point inside the `try` block,
  // such as a database connection failure or a query error.
  } catch (error) {

    // `console.error()`: This is a standard Node.js function for logging messages, specifically
    // for errors. It prints to the standard error stream, which often makes the output appear
    // in red in many terminals, clearly highlighting that something went wrong.
    // We are logging a descriptive prefix string and the actual `error` object that was caught.
    console.error("Error during global setup:", error);

    // This is a critical command that immediately terminates the entire Node.js process.
    // `process.exit(1)`: The `1` is an "exit code". By convention, an exit code of `0` means
    // the process finished successfully, while any non-zero number (like `1`) signals that
    // it terminated due to an error.
    //
    // This is a "fail-fast" safety measure. If the database setup fails for any reason, we
    // must stop the entire test suite immediately. It would be pointless and potentially
    // dangerous to try and run the tests against a database that is not in a clean,
    // predictable state.
    process.exit(1);

  // The `finally` block is a special part of the `try...catch` statement.
  // The code inside `finally` is GUARANTEED to be executed, regardless of whether the `try`
  // block completed successfully or the `catch` block was triggered by an error.
  // This makes it the perfect and most reliable place for essential cleanup operations.
  } finally {
    
    // This line explicitly closes the connection to the database.
    // It's a best practice to always disconnect the Prisma Client when a script's task is
    // complete. This gracefully releases the connection back to the database pool, preventing
    // "dangling" or "zombie" connections that could exhaust the database's connection limit.
    // Because this is in a `finally` block, we can be sure the connection will be closed
    // even if the seeding logic throws an error.
    await prisma.$disconnect();
  }
}

// This is the standard ES Module syntax for exporting a single, default value from a file.
// We are exporting the `globalSetup` function itself. Playwright is configured to look for this
// default export in the file specified in the `globalSetup` configuration option in `playwright.config.ts`,
// and it will then execute this function before starting the tests.
export default globalSetup;