// This is the Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// This block configures the "generator" for Prisma. A generator takes your
// schema as input and produces an output. The 'prisma-client-js' provider
// is the most important one: it reads all your models (User, Post, etc.) and
// generates the fully type-safe Prisma Client library into your `node_modules`
// folder. This is the client you import and use in your application code to
// talk to the database.
generator client {
    provider = "prisma-client-js"
}

// 'provider' tells Prisma which database driver to use (e.g., "postgresql", "mysql", "sqlite").
// 'url' specifies the connection string. env("DATABASE_URL") is an environment variable.
datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// This model is essential for integrating NextAuth.js for authentication.
// It is not a model you typically create or query directly. NextAuth's Prisma adapter
// uses it automatically to link accounts from different OAuth providers (e.g., Google, GitHub)
// to a single User record in your database. The `Session` model is used separately to manage
// the user's active sign-in state.

// - @relation(onDelete: Cascade): This is a crucial rule. It means if a User is
//   deleted, all of their linked Account records will be automatically deleted too,
//   maintaining data integrity.
// - @relation(fields: [userId], references: [id]): Defines a one-to-many relationship. It links this Account to a User,
//   specifying that 'userId' is the foreign key that references the 'id' on the User model.

// - @@unique([provider, providerAccountId]): 
// This is a compound (or multi-column) unique constraint.
// Its purpose is to ensure that a specific account from an external provider
// (e.g., a single Google account) can only be linked ONCE across the entire application.
//
//   - `@@`: This prefix signifies a "block-level attribute". It applies to the entire
//           model, not just a single field (which would use a single `@`).
//   - `unique`: This is the name of the constraint, telling the database to enforce uniqueness.
//   - `[...]`: The square brackets define an array or list of fields that the
//              constraint should apply to.
//   - `provider, providerAccountId`: These are the names of the fields in this model
//     that form the compound key. The constraint applies to the *combination* of these fields.
//
// In plain English, this line means: "The combination of a 'provider' value (e.g., "google")
// and a 'providerAccountId' value (e.g., "1098...765") must be unique across all rows in this table."
//
// This prevents two main problems:
//   1. A user cannot link the exact same Google account to their profile multiple times.
//   2. The same Google account cannot be linked to two different user profiles in your app.
//
// What this does NOT prevent:
//   A single user CAN link multiple different accounts from the same provider (e.g.,
//   both `personal@gmail.com` and `work@gmail.com`) to their one user profile, as
//   each would have a unique `providerAccountId`.

// - '?' following a datatype means the field is optional/nullable, which is necessary as
//   not all OAuth providers return the same data (e.g., refresh_token).
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

// This model is another requirement for NextAuth.js. It's used to store
// session data, linking a `sessionToken` (usually stored in a browser cookie)
// back to a specific user in your database. NextAuth manages the creation,
// validation, and expiration of these sessions automatically.
// - @unique: Ensures that every session token is unique.
// - @relation: This establishes a many-to-one relationship between Session and User, where
// a single user can have multiple sessions, but each session is associated with
// only one user (since userId is not unique).
//(..., onDelete: Cascade): A critical setting for data integrity. If a User
//   record is deleted, all of their associated Session records will be
//   automatically deleted from the database as well.
model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// This is the central User model for your application. It holds profile
// information for each user.
//
// - id @default(cuid()): A unique, URL-safe identifier for the user.
// - The fields with a `?` (name, email, emailVerified, image) are optional,
//   as not all auth providers return this data, or a user may not have set it.
// - email @unique: Guarantees no two users can have the same email address.
// - password: Stores the hashed password for the NextAuth.js "Credentials" provider,
//   enabling traditional email/password login. NEVER store plain text passwords.
// - verificationToken: A temporary token for one-time email verification, often used
//   after a user signs up with a password.
// - accounts[], sessions[], posts[]: These are "back-relations". They do NOT
//   create columns in the 'User' table. Instead, they are type-safe shortcuts
//   for the Prisma Client, allowing you to easily query related data. For example:
//   `prisma.user.findUnique({ where: { id: "..." }, include: { posts: true } })`.
model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    password      String
    verificationToken String? @unique
    image         String?
    accounts      Account[]
    sessions      Session[]
}

// This model is used by NextAuth for "magic link" email sign-in. When a user
// requests a sign-in link, NextAuth generates a secure, one-time-use token,
// stores it in this table with an expiration date, and emails it to the user.
// When the user clicks the link, NextAuth verifies the token against this table.
//
// - token @unique: Guarantees that every token in the table is globally unique.
// - @@unique([identifier, token]): This compound constraint is the official NextAuth
//   recommendation. It ensures a single user (identifier) cannot have multiple
//   identical tokens.
model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}


// This model is used to store tasks for a to-do list application.
//
// - @id @default(cuid()): Uses CUIDs for unique, non-sequential primary keys. This is
//   generally preferred over auto-incrementing integers for security and scalability.
// - completed @default(false): A new task will be marked as not completed by default.
// - createdAt @default(now()) & updatedAt @updatedAt: Standard timestamp fields
//   that automatically track when a record is created and last modified.
 model Task {
     id        String   @id @default(cuid())
     title     String
     completed Boolean  @default(false)
     createdAt DateTime @default(now())
     updatedAt DateTime @updatedAt
   }
